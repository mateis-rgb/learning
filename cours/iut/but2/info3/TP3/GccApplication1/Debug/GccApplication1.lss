
GccApplication1.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00001f92  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000024c  00800060  00001f92  00002026  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000002e6  008002ac  008002ac  00002272  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  00002272  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  000022d0  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000002e8  00000000  00000000  0000230c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00003bf2  00000000  00000000  000025f4  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000106e  00000000  00000000  000061e6  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00002142  00000000  00000000  00007254  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000bb0  00000000  00000000  00009398  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000d39  00000000  00000000  00009f48  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000041ce  00000000  00000000  0000ac81  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000278  00000000  00000000  0000ee4f  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 6d 08 	jmp	0x10da	; 0x10da <__vector_4>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	12 e0       	ldi	r17, 0x02	; 2
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e2 e9       	ldi	r30, 0x92	; 146
      68:	ff e1       	ldi	r31, 0x1F	; 31
      6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0
      70:	ac 3a       	cpi	r26, 0xAC	; 172
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
      76:	25 e0       	ldi	r18, 0x05	; 5
      78:	ac ea       	ldi	r26, 0xAC	; 172
      7a:	b2 e0       	ldi	r27, 0x02	; 2
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a2 39       	cpi	r26, 0x92	; 146
      82:	b2 07       	cpc	r27, r18
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 d9 08 	call	0x11b2	; 0x11b2 <main>
      8a:	0c 94 c7 0f 	jmp	0x1f8e	; 0x1f8e <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <CRC16>:
	0xef1f,0xff3e,0xcf5d,0xdf7c,0xaf9b,0xbfba,0x8fd9,0x9ff8,
	0x6e17,0x7e36,0x4e55,0x5e74,0x2e93,0x3eb2,0x0ed1,0x1ef0
};
  
u16 CRC16(const u8 *pBuffer, u32 len)
{
      92:	cf 92       	push	r12
      94:	df 92       	push	r13
      96:	ef 92       	push	r14
      98:	ff 92       	push	r15
      9a:	dc 01       	movw	r26, r24
	register u32 counter;
	register u16 crc = 0;
      9c:	80 e0       	ldi	r24, 0x00	; 0
      9e:	90 e0       	ldi	r25, 0x00	; 0
	for( counter = 0; counter < len; counter++)
      a0:	c1 2c       	mov	r12, r1
      a2:	d1 2c       	mov	r13, r1
      a4:	76 01       	movw	r14, r12
      a6:	14 c0       	rjmp	.+40     	; 0xd0 <CRC16+0x3e>
		crc = (crc<<8) ^ crc16tab[((crc>>8) ^ *pBuffer++)&0x00FF];
      a8:	38 2f       	mov	r19, r24
      aa:	22 27       	eor	r18, r18
      ac:	e9 2f       	mov	r30, r25
      ae:	ff 27       	eor	r31, r31
      b0:	8c 91       	ld	r24, X
      b2:	e8 27       	eor	r30, r24
      b4:	ee 0f       	add	r30, r30
      b6:	ff 1f       	adc	r31, r31
      b8:	e6 57       	subi	r30, 0x76	; 118
      ba:	ff 4f       	sbci	r31, 0xFF	; 255
      bc:	80 81       	ld	r24, Z
      be:	91 81       	ldd	r25, Z+1	; 0x01
      c0:	82 27       	eor	r24, r18
      c2:	93 27       	eor	r25, r19
  
u16 CRC16(const u8 *pBuffer, u32 len)
{
	register u32 counter;
	register u16 crc = 0;
	for( counter = 0; counter < len; counter++)
      c4:	2f ef       	ldi	r18, 0xFF	; 255
      c6:	c2 1a       	sub	r12, r18
      c8:	d2 0a       	sbc	r13, r18
      ca:	e2 0a       	sbc	r14, r18
      cc:	f2 0a       	sbc	r15, r18
		crc = (crc<<8) ^ crc16tab[((crc>>8) ^ *pBuffer++)&0x00FF];
      ce:	11 96       	adiw	r26, 0x01	; 1
  
u16 CRC16(const u8 *pBuffer, u32 len)
{
	register u32 counter;
	register u16 crc = 0;
	for( counter = 0; counter < len; counter++)
      d0:	c4 16       	cp	r12, r20
      d2:	d5 06       	cpc	r13, r21
      d4:	e6 06       	cpc	r14, r22
      d6:	f7 06       	cpc	r15, r23
      d8:	38 f3       	brcs	.-50     	; 0xa8 <CRC16+0x16>
		crc = (crc<<8) ^ crc16tab[((crc>>8) ^ *pBuffer++)&0x00FF];
	return crc;
}
      da:	ff 90       	pop	r15
      dc:	ef 90       	pop	r14
      de:	df 90       	pop	r13
      e0:	cf 90       	pop	r12
      e2:	08 95       	ret

000000e4 <InitFat16>:
	{
		fputchar_(file,string[i]);
		i++;
	}
	return(0);
}
      e4:	cf 92       	push	r12
      e6:	df 92       	push	r13
      e8:	ef 92       	push	r14
      ea:	ff 92       	push	r15
      ec:	cf 93       	push	r28
      ee:	c0 e0       	ldi	r28, 0x00	; 0
      f0:	0c c0       	rjmp	.+24     	; 0x10a <InitFat16+0x26>
      f2:	83 e2       	ldi	r24, 0x23	; 35
      f4:	92 e0       	ldi	r25, 0x02	; 2
      f6:	c8 9f       	mul	r28, r24
      f8:	f0 01       	movw	r30, r0
      fa:	c9 9f       	mul	r28, r25
      fc:	f0 0d       	add	r31, r0
      fe:	11 24       	eor	r1, r1
     100:	e1 51       	subi	r30, 0x11	; 17
     102:	fb 4f       	sbci	r31, 0xFB	; 251
     104:	81 e0       	ldi	r24, 0x01	; 1
     106:	80 83       	st	Z, r24
     108:	cf 5f       	subi	r28, 0xFF	; 255
     10a:	cc 23       	and	r28, r28
     10c:	91 f3       	breq	.-28     	; 0xf2 <InitFat16+0xe>
     10e:	01 c0       	rjmp	.+2      	; 0x112 <InitFat16+0x2e>
     110:	c8 2f       	mov	r28, r24
     112:	0e 94 73 0a 	call	0x14e6	; 0x14e6 <SDC_Init>
     116:	88 23       	and	r24, r24
     118:	29 f0       	breq	.+10     	; 0x124 <InitFat16+0x40>
     11a:	81 e0       	ldi	r24, 0x01	; 1
     11c:	8c 0f       	add	r24, r28
     11e:	c4 36       	cpi	r28, 0x64	; 100
     120:	b8 f3       	brcs	.-18     	; 0x110 <InitFat16+0x2c>
     122:	c8 2f       	mov	r28, r24
     124:	c4 36       	cpi	r28, 0x64	; 100
     126:	08 f0       	brcs	.+2      	; 0x12a <InitFat16+0x46>
     128:	88 c0       	rjmp	.+272    	; 0x23a <InitFat16+0x156>
     12a:	4f ee       	ldi	r20, 0xEF	; 239
     12c:	52 e0       	ldi	r21, 0x02	; 2
     12e:	60 e0       	ldi	r22, 0x00	; 0
     130:	70 e0       	ldi	r23, 0x00	; 0
     132:	cb 01       	movw	r24, r22
     134:	0e 94 69 0c 	call	0x18d2	; 0x18d2 <SDC_GetSector>
     138:	60 91 b5 04 	lds	r22, 0x04B5	; 0x8004b5 <FilePointer+0x1e8>
     13c:	70 91 b6 04 	lds	r23, 0x04B6	; 0x8004b6 <FilePointer+0x1e9>
     140:	80 91 b7 04 	lds	r24, 0x04B7	; 0x8004b7 <FilePointer+0x1ea>
     144:	90 91 b8 04 	lds	r25, 0x04B8	; 0x8004b8 <FilePointer+0x1eb>
     148:	60 93 bc 02 	sts	0x02BC, r22	; 0x8002bc <FirstPartitionSector>
     14c:	70 93 bd 02 	sts	0x02BD, r23	; 0x8002bd <FirstPartitionSector+0x1>
     150:	80 93 be 02 	sts	0x02BE, r24	; 0x8002be <FirstPartitionSector+0x2>
     154:	90 93 bf 02 	sts	0x02BF, r25	; 0x8002bf <FirstPartitionSector+0x3>
     158:	20 91 b1 04 	lds	r18, 0x04B1	; 0x8004b1 <FilePointer+0x1e4>
     15c:	2e 30       	cpi	r18, 0x0E	; 14
     15e:	29 f0       	breq	.+10     	; 0x16a <InitFat16+0x86>
     160:	24 30       	cpi	r18, 0x04	; 4
     162:	19 f0       	breq	.+6      	; 0x16a <InitFat16+0x86>
     164:	26 30       	cpi	r18, 0x06	; 6
     166:	09 f0       	breq	.+2      	; 0x16a <InitFat16+0x86>
     168:	6a c0       	rjmp	.+212    	; 0x23e <InitFat16+0x15a>
     16a:	4f ee       	ldi	r20, 0xEF	; 239
     16c:	52 e0       	ldi	r21, 0x02	; 2
     16e:	0e 94 69 0c 	call	0x18d2	; 0x18d2 <SDC_GetSector>
     172:	ed ec       	ldi	r30, 0xCD	; 205
     174:	f2 e0       	ldi	r31, 0x02	; 2
     176:	87 a5       	ldd	r24, Z+47	; 0x2f
     178:	80 93 c9 02 	sts	0x02C9, r24	; 0x8002c9 <SectorsPerCluster>
     17c:	62 a9       	ldd	r22, Z+50	; 0x32
     17e:	60 93 c8 02 	sts	0x02C8, r22	; 0x8002c8 <FatCopies>
     182:	43 a9       	ldd	r20, Z+51	; 0x33
     184:	54 a9       	ldd	r21, Z+52	; 0x34
     186:	50 93 c7 02 	sts	0x02C7, r21	; 0x8002c7 <PossibleRootEntries+0x1>
     18a:	40 93 c6 02 	sts	0x02C6, r20	; 0x8002c6 <PossibleRootEntries>
     18e:	20 ad       	ldd	r18, Z+56	; 0x38
     190:	31 ad       	ldd	r19, Z+57	; 0x39
     192:	30 93 c5 02 	sts	0x02C5, r19	; 0x8002c5 <SectorsPerFat+0x1>
     196:	20 93 c4 02 	sts	0x02C4, r18	; 0x8002c4 <SectorsPerFat>
     19a:	c0 a8       	ldd	r12, Z+48	; 0x30
     19c:	d1 a8       	ldd	r13, Z+49	; 0x31
     19e:	e1 2c       	mov	r14, r1
     1a0:	f1 2c       	mov	r15, r1
     1a2:	c0 92 c0 02 	sts	0x02C0, r12	; 0x8002c0 <ReservedSectors>
     1a6:	d0 92 c1 02 	sts	0x02C1, r13	; 0x8002c1 <ReservedSectors+0x1>
     1aa:	e0 92 c2 02 	sts	0x02C2, r14	; 0x8002c2 <ReservedSectors+0x2>
     1ae:	f0 92 c3 02 	sts	0x02C3, r15	; 0x8002c3 <ReservedSectors+0x3>
     1b2:	80 91 bc 02 	lds	r24, 0x02BC	; 0x8002bc <FirstPartitionSector>
     1b6:	90 91 bd 02 	lds	r25, 0x02BD	; 0x8002bd <FirstPartitionSector+0x1>
     1ba:	a0 91 be 02 	lds	r26, 0x02BE	; 0x8002be <FirstPartitionSector+0x2>
     1be:	b0 91 bf 02 	lds	r27, 0x02BF	; 0x8002bf <FirstPartitionSector+0x3>
     1c2:	c8 0e       	add	r12, r24
     1c4:	d9 1e       	adc	r13, r25
     1c6:	ea 1e       	adc	r14, r26
     1c8:	fb 1e       	adc	r15, r27
     1ca:	c0 92 b8 02 	sts	0x02B8, r12	; 0x8002b8 <FileAllocationTable>
     1ce:	d0 92 b9 02 	sts	0x02B9, r13	; 0x8002b9 <FileAllocationTable+0x1>
     1d2:	e0 92 ba 02 	sts	0x02BA, r14	; 0x8002ba <FileAllocationTable+0x2>
     1d6:	f0 92 bb 02 	sts	0x02BB, r15	; 0x8002bb <FileAllocationTable+0x3>
     1da:	a6 2f       	mov	r26, r22
     1dc:	b0 e0       	ldi	r27, 0x00	; 0
     1de:	0e 94 cf 0c 	call	0x199e	; 0x199e <__umulhisi3>
     1e2:	dc 01       	movw	r26, r24
     1e4:	cb 01       	movw	r24, r22
     1e6:	8c 0d       	add	r24, r12
     1e8:	9d 1d       	adc	r25, r13
     1ea:	ae 1d       	adc	r26, r14
     1ec:	bf 1d       	adc	r27, r15
     1ee:	80 93 b4 02 	sts	0x02B4, r24	; 0x8002b4 <RootDirectory>
     1f2:	90 93 b5 02 	sts	0x02B5, r25	; 0x8002b5 <RootDirectory+0x1>
     1f6:	a0 93 b6 02 	sts	0x02B6, r26	; 0x8002b6 <RootDirectory+0x2>
     1fa:	b0 93 b7 02 	sts	0x02B7, r27	; 0x8002b7 <RootDirectory+0x3>
     1fe:	52 95       	swap	r21
     200:	42 95       	swap	r20
     202:	4f 70       	andi	r20, 0x0F	; 15
     204:	45 27       	eor	r20, r21
     206:	5f 70       	andi	r21, 0x0F	; 15
     208:	45 27       	eor	r20, r21
     20a:	6c 01       	movw	r12, r24
     20c:	7d 01       	movw	r14, r26
     20e:	c4 0e       	add	r12, r20
     210:	d5 1e       	adc	r13, r21
     212:	e1 1c       	adc	r14, r1
     214:	f1 1c       	adc	r15, r1
     216:	c0 92 b0 02 	sts	0x02B0, r12	; 0x8002b0 <FirstDataCluster>
     21a:	d0 92 b1 02 	sts	0x02B1, r13	; 0x8002b1 <FirstDataCluster+0x1>
     21e:	e0 92 b2 02 	sts	0x02B2, r14	; 0x8002b2 <FirstDataCluster+0x2>
     222:	f0 92 b3 02 	sts	0x02B3, r15	; 0x8002b3 <FirstDataCluster+0x3>
     226:	80 93 ac 02 	sts	0x02AC, r24	; 0x8002ac <__data_end>
     22a:	90 93 ad 02 	sts	0x02AD, r25	; 0x8002ad <__data_end+0x1>
     22e:	a0 93 ae 02 	sts	0x02AE, r26	; 0x8002ae <__data_end+0x2>
     232:	b0 93 af 02 	sts	0x02AF, r27	; 0x8002af <__data_end+0x3>
     236:	81 e0       	ldi	r24, 0x01	; 1
     238:	03 c0       	rjmp	.+6      	; 0x240 <InitFat16+0x15c>
     23a:	80 e0       	ldi	r24, 0x00	; 0
     23c:	01 c0       	rjmp	.+2      	; 0x240 <InitFat16+0x15c>
     23e:	80 e0       	ldi	r24, 0x00	; 0
     240:	cf 91       	pop	r28
     242:	ff 90       	pop	r15
     244:	ef 90       	pop	r14
     246:	df 90       	pop	r13
     248:	cf 90       	pop	r12
     24a:	08 95       	ret

0000024c <fflush_>:
     24c:	0f 93       	push	r16
     24e:	1f 93       	push	r17
     250:	cf 93       	push	r28
     252:	df 93       	push	r29
     254:	00 97       	sbiw	r24, 0x00	; 0
     256:	09 f4       	brne	.+2      	; 0x25a <fflush_+0xe>
     258:	52 c0       	rjmp	.+164    	; 0x2fe <fflush_+0xb2>
     25a:	fc 01       	movw	r30, r24
     25c:	23 85       	ldd	r18, Z+11	; 0x0b
     25e:	21 36       	cpi	r18, 0x61	; 97
     260:	19 f0       	breq	.+6      	; 0x268 <fflush_+0x1c>
     262:	27 37       	cpi	r18, 0x77	; 119
     264:	09 f0       	breq	.+2      	; 0x268 <fflush_+0x1c>
     266:	4b c0       	rjmp	.+150    	; 0x2fe <fflush_+0xb2>
     268:	ec 01       	movw	r28, r24
     26a:	89 85       	ldd	r24, Y+9	; 0x09
     26c:	9a 85       	ldd	r25, Y+10	; 0x0a
     26e:	89 2b       	or	r24, r25
     270:	81 f0       	breq	.+32     	; 0x292 <fflush_+0x46>
     272:	8c 81       	ldd	r24, Y+4	; 0x04
     274:	9d 81       	ldd	r25, Y+5	; 0x05
     276:	ae 81       	ldd	r26, Y+6	; 0x06
     278:	bf 81       	ldd	r27, Y+7	; 0x07
     27a:	28 85       	ldd	r18, Y+8	; 0x08
     27c:	bc 01       	movw	r22, r24
     27e:	cd 01       	movw	r24, r26
     280:	62 0f       	add	r22, r18
     282:	71 1d       	adc	r23, r1
     284:	81 1d       	adc	r24, r1
     286:	91 1d       	adc	r25, r1
     288:	ae 01       	movw	r20, r28
     28a:	4e 5d       	subi	r20, 0xDE	; 222
     28c:	5f 4f       	sbci	r21, 0xFF	; 255
     28e:	0e 94 e3 0b 	call	0x17c6	; 0x17c6 <SDC_PutSector>
     292:	8e 01       	movw	r16, r28
     294:	0e 5d       	subi	r16, 0xDE	; 222
     296:	1f 4f       	sbci	r17, 0xFF	; 255
     298:	6c 8d       	ldd	r22, Y+28	; 0x1c
     29a:	7d 8d       	ldd	r23, Y+29	; 0x1d
     29c:	8e 8d       	ldd	r24, Y+30	; 0x1e
     29e:	9f 8d       	ldd	r25, Y+31	; 0x1f
     2a0:	a8 01       	movw	r20, r16
     2a2:	0e 94 69 0c 	call	0x18d2	; 0x18d2 <SDC_GetSector>
     2a6:	10 93 cc 02 	sts	0x02CC, r17	; 0x8002cc <DirectoryEntry+0x1>
     2aa:	00 93 cb 02 	sts	0x02CB, r16	; 0x8002cb <DirectoryEntry>
     2ae:	88 a1       	ldd	r24, Y+32	; 0x20
     2b0:	f8 01       	movw	r30, r16
     2b2:	90 e2       	ldi	r25, 0x20	; 32
     2b4:	89 9f       	mul	r24, r25
     2b6:	e0 0d       	add	r30, r0
     2b8:	f1 1d       	adc	r31, r1
     2ba:	11 24       	eor	r1, r1
     2bc:	8c 85       	ldd	r24, Y+12	; 0x0c
     2be:	9d 85       	ldd	r25, Y+13	; 0x0d
     2c0:	ae 85       	ldd	r26, Y+14	; 0x0e
     2c2:	bf 85       	ldd	r27, Y+15	; 0x0f
     2c4:	84 8f       	std	Z+28, r24	; 0x1c
     2c6:	95 8f       	std	Z+29, r25	; 0x1d
     2c8:	a6 8f       	std	Z+30, r26	; 0x1e
     2ca:	b7 8f       	std	Z+31, r27	; 0x1f
     2cc:	88 a1       	ldd	r24, Y+32	; 0x20
     2ce:	f8 01       	movw	r30, r16
     2d0:	90 e2       	ldi	r25, 0x20	; 32
     2d2:	89 9f       	mul	r24, r25
     2d4:	e0 0d       	add	r30, r0
     2d6:	f1 1d       	adc	r31, r1
     2d8:	11 24       	eor	r1, r1
     2da:	17 8a       	std	Z+23, r1	; 0x17
     2dc:	16 8a       	std	Z+22, r1	; 0x16
     2de:	88 a1       	ldd	r24, Y+32	; 0x20
     2e0:	f8 01       	movw	r30, r16
     2e2:	90 e2       	ldi	r25, 0x20	; 32
     2e4:	89 9f       	mul	r24, r25
     2e6:	e0 0d       	add	r30, r0
     2e8:	f1 1d       	adc	r31, r1
     2ea:	11 24       	eor	r1, r1
     2ec:	11 8e       	std	Z+25, r1	; 0x19
     2ee:	10 8e       	std	Z+24, r1	; 0x18
     2f0:	6c 8d       	ldd	r22, Y+28	; 0x1c
     2f2:	7d 8d       	ldd	r23, Y+29	; 0x1d
     2f4:	8e 8d       	ldd	r24, Y+30	; 0x1e
     2f6:	9f 8d       	ldd	r25, Y+31	; 0x1f
     2f8:	a8 01       	movw	r20, r16
     2fa:	0e 94 e3 0b 	call	0x17c6	; 0x17c6 <SDC_PutSector>
     2fe:	80 e0       	ldi	r24, 0x00	; 0
     300:	90 e0       	ldi	r25, 0x00	; 0
     302:	df 91       	pop	r29
     304:	cf 91       	pop	r28
     306:	1f 91       	pop	r17
     308:	0f 91       	pop	r16
     30a:	08 95       	ret

0000030c <GetNextCluster>:
     30c:	8f 92       	push	r8
     30e:	9f 92       	push	r9
     310:	af 92       	push	r10
     312:	bf 92       	push	r11
     314:	cf 92       	push	r12
     316:	df 92       	push	r13
     318:	ef 92       	push	r14
     31a:	ff 92       	push	r15
     31c:	0f 93       	push	r16
     31e:	1f 93       	push	r17
     320:	cf 93       	push	r28
     322:	df 93       	push	r29
     324:	fc 01       	movw	r30, r24
     326:	04 81       	ldd	r16, Z+4	; 0x04
     328:	15 81       	ldd	r17, Z+5	; 0x05
     32a:	26 81       	ldd	r18, Z+6	; 0x06
     32c:	37 81       	ldd	r19, Z+7	; 0x07
     32e:	40 91 b4 02 	lds	r20, 0x02B4	; 0x8002b4 <RootDirectory>
     332:	50 91 b5 02 	lds	r21, 0x02B5	; 0x8002b5 <RootDirectory+0x1>
     336:	60 91 b6 02 	lds	r22, 0x02B6	; 0x8002b6 <RootDirectory+0x2>
     33a:	70 91 b7 02 	lds	r23, 0x02B7	; 0x8002b7 <RootDirectory+0x3>
     33e:	04 17       	cp	r16, r20
     340:	15 07       	cpc	r17, r21
     342:	26 07       	cpc	r18, r22
     344:	37 07       	cpc	r19, r23
     346:	b8 f0       	brcs	.+46     	; 0x376 <GetNextCluster+0x6a>
     348:	6a 01       	movw	r12, r20
     34a:	7b 01       	movw	r14, r22
     34c:	ff e1       	ldi	r31, 0x1F	; 31
     34e:	cf 0e       	add	r12, r31
     350:	d1 1c       	adc	r13, r1
     352:	e1 1c       	adc	r14, r1
     354:	f1 1c       	adc	r15, r1
     356:	0c 15       	cp	r16, r12
     358:	1d 05       	cpc	r17, r13
     35a:	2e 05       	cpc	r18, r14
     35c:	3f 05       	cpc	r19, r15
     35e:	58 f4       	brcc	.+22     	; 0x376 <GetNextCluster+0x6a>
     360:	0f 5f       	subi	r16, 0xFF	; 255
     362:	1f 4f       	sbci	r17, 0xFF	; 255
     364:	2f 4f       	sbci	r18, 0xFF	; 255
     366:	3f 4f       	sbci	r19, 0xFF	; 255
     368:	fc 01       	movw	r30, r24
     36a:	04 83       	std	Z+4, r16	; 0x04
     36c:	15 83       	std	Z+5, r17	; 0x05
     36e:	26 83       	std	Z+6, r18	; 0x06
     370:	37 83       	std	Z+7, r19	; 0x07
     372:	81 e0       	ldi	r24, 0x01	; 1
     374:	9e c0       	rjmp	.+316    	; 0x4b2 <__EEPROM_REGION_LENGTH__+0xb2>
     376:	41 5e       	subi	r20, 0xE1	; 225
     378:	5f 4f       	sbci	r21, 0xFF	; 255
     37a:	6f 4f       	sbci	r22, 0xFF	; 255
     37c:	7f 4f       	sbci	r23, 0xFF	; 255
     37e:	40 17       	cp	r20, r16
     380:	51 07       	cpc	r21, r17
     382:	62 07       	cpc	r22, r18
     384:	73 07       	cpc	r23, r19
     386:	08 f0       	brcs	.+2      	; 0x38a <GetNextCluster+0x7e>
     388:	91 c0       	rjmp	.+290    	; 0x4ac <__EEPROM_REGION_LENGTH__+0xac>
     38a:	ec 01       	movw	r28, r24
     38c:	80 91 b0 02 	lds	r24, 0x02B0	; 0x8002b0 <FirstDataCluster>
     390:	90 91 b1 02 	lds	r25, 0x02B1	; 0x8002b1 <FirstDataCluster+0x1>
     394:	a0 91 b2 02 	lds	r26, 0x02B2	; 0x8002b2 <FirstDataCluster+0x2>
     398:	b0 91 b3 02 	lds	r27, 0x02B3	; 0x8002b3 <FirstDataCluster+0x3>
     39c:	68 01       	movw	r12, r16
     39e:	79 01       	movw	r14, r18
     3a0:	c8 1a       	sub	r12, r24
     3a2:	d9 0a       	sbc	r13, r25
     3a4:	ea 0a       	sbc	r14, r26
     3a6:	fb 0a       	sbc	r15, r27
     3a8:	c7 01       	movw	r24, r14
     3aa:	b6 01       	movw	r22, r12
     3ac:	20 91 c9 02 	lds	r18, 0x02C9	; 0x8002c9 <SectorsPerCluster>
     3b0:	30 e0       	ldi	r19, 0x00	; 0
     3b2:	40 e0       	ldi	r20, 0x00	; 0
     3b4:	50 e0       	ldi	r21, 0x00	; 0
     3b6:	0e 94 ad 0c 	call	0x195a	; 0x195a <__udivmodsi4>
     3ba:	69 01       	movw	r12, r18
     3bc:	7a 01       	movw	r14, r20
     3be:	02 e0       	ldi	r16, 0x02	; 2
     3c0:	c0 0e       	add	r12, r16
     3c2:	d1 1c       	adc	r13, r1
     3c4:	e1 1c       	adc	r14, r1
     3c6:	f1 1c       	adc	r15, r1
     3c8:	46 01       	movw	r8, r12
     3ca:	57 01       	movw	r10, r14
     3cc:	99 24       	eor	r9, r9
     3ce:	aa 24       	eor	r10, r10
     3d0:	bb 24       	eor	r11, r11
     3d2:	cd 2c       	mov	r12, r13
     3d4:	de 2c       	mov	r13, r14
     3d6:	ef 2c       	mov	r14, r15
     3d8:	ff 24       	eor	r15, r15
     3da:	ae 01       	movw	r20, r28
     3dc:	4e 5d       	subi	r20, 0xDE	; 222
     3de:	5f 4f       	sbci	r21, 0xFF	; 255
     3e0:	80 91 b8 02 	lds	r24, 0x02B8	; 0x8002b8 <FileAllocationTable>
     3e4:	90 91 b9 02 	lds	r25, 0x02B9	; 0x8002b9 <FileAllocationTable+0x1>
     3e8:	a0 91 ba 02 	lds	r26, 0x02BA	; 0x8002ba <FileAllocationTable+0x2>
     3ec:	b0 91 bb 02 	lds	r27, 0x02BB	; 0x8002bb <FileAllocationTable+0x3>
     3f0:	bc 01       	movw	r22, r24
     3f2:	cd 01       	movw	r24, r26
     3f4:	6c 0d       	add	r22, r12
     3f6:	7d 1d       	adc	r23, r13
     3f8:	8e 1d       	adc	r24, r14
     3fa:	9f 1d       	adc	r25, r15
     3fc:	0e 94 69 0c 	call	0x18d2	; 0x18d2 <SDC_GetSector>
     400:	80 91 b8 02 	lds	r24, 0x02B8	; 0x8002b8 <FileAllocationTable>
     404:	90 91 b9 02 	lds	r25, 0x02B9	; 0x8002b9 <FileAllocationTable+0x1>
     408:	a0 91 ba 02 	lds	r26, 0x02BA	; 0x8002ba <FileAllocationTable+0x2>
     40c:	b0 91 bb 02 	lds	r27, 0x02BB	; 0x8002bb <FileAllocationTable+0x3>
     410:	c8 0e       	add	r12, r24
     412:	d9 1e       	adc	r13, r25
     414:	ea 1e       	adc	r14, r26
     416:	fb 1e       	adc	r15, r27
     418:	cc 8a       	std	Y+20, r12	; 0x14
     41a:	dd 8a       	std	Y+21, r13	; 0x15
     41c:	ee 8a       	std	Y+22, r14	; 0x16
     41e:	ff 8a       	std	Y+23, r15	; 0x17
     420:	d5 01       	movw	r26, r10
     422:	c4 01       	movw	r24, r8
     424:	88 0f       	add	r24, r24
     426:	99 1f       	adc	r25, r25
     428:	aa 1f       	adc	r26, r26
     42a:	bb 1f       	adc	r27, r27
     42c:	ac 01       	movw	r20, r24
     42e:	bd 01       	movw	r22, r26
     430:	4f 5f       	subi	r20, 0xFF	; 255
     432:	5f 4f       	sbci	r21, 0xFF	; 255
     434:	6f 4f       	sbci	r22, 0xFF	; 255
     436:	7f 4f       	sbci	r23, 0xFF	; 255
     438:	fe 01       	movw	r30, r28
     43a:	e4 0f       	add	r30, r20
     43c:	f5 1f       	adc	r31, r21
     43e:	22 a1       	ldd	r18, Z+34	; 0x22
     440:	42 2f       	mov	r20, r18
     442:	50 e0       	ldi	r21, 0x00	; 0
     444:	60 e0       	ldi	r22, 0x00	; 0
     446:	70 e0       	ldi	r23, 0x00	; 0
     448:	76 2f       	mov	r23, r22
     44a:	65 2f       	mov	r22, r21
     44c:	54 2f       	mov	r21, r20
     44e:	44 27       	eor	r20, r20
     450:	fe 01       	movw	r30, r28
     452:	e8 0f       	add	r30, r24
     454:	f9 1f       	adc	r31, r25
     456:	82 a1       	ldd	r24, Z+34	; 0x22
     458:	6a 01       	movw	r12, r20
     45a:	7b 01       	movw	r14, r22
     45c:	c8 2a       	or	r12, r24
     45e:	d7 01       	movw	r26, r14
     460:	c6 01       	movw	r24, r12
     462:	9c 01       	movw	r18, r24
     464:	ad 01       	movw	r20, r26
     466:	22 50       	subi	r18, 0x02	; 2
     468:	31 09       	sbc	r19, r1
     46a:	41 09       	sbc	r20, r1
     46c:	51 09       	sbc	r21, r1
     46e:	a0 91 c9 02 	lds	r26, 0x02C9	; 0x8002c9 <SectorsPerCluster>
     472:	b0 e0       	ldi	r27, 0x00	; 0
     474:	0e 94 de 0c 	call	0x19bc	; 0x19bc <__muluhisi3>
     478:	00 91 b0 02 	lds	r16, 0x02B0	; 0x8002b0 <FirstDataCluster>
     47c:	10 91 b1 02 	lds	r17, 0x02B1	; 0x8002b1 <FirstDataCluster+0x1>
     480:	20 91 b2 02 	lds	r18, 0x02B2	; 0x8002b2 <FirstDataCluster+0x2>
     484:	30 91 b3 02 	lds	r19, 0x02B3	; 0x8002b3 <FirstDataCluster+0x3>
     488:	dc 01       	movw	r26, r24
     48a:	cb 01       	movw	r24, r22
     48c:	80 0f       	add	r24, r16
     48e:	91 1f       	adc	r25, r17
     490:	a2 1f       	adc	r26, r18
     492:	b3 1f       	adc	r27, r19
     494:	87 3f       	cpi	r24, 0xF7	; 247
     496:	0f ef       	ldi	r16, 0xFF	; 255
     498:	90 07       	cpc	r25, r16
     49a:	a1 05       	cpc	r26, r1
     49c:	b1 05       	cpc	r27, r1
     49e:	40 f4       	brcc	.+16     	; 0x4b0 <__EEPROM_REGION_LENGTH__+0xb0>
     4a0:	8c 83       	std	Y+4, r24	; 0x04
     4a2:	9d 83       	std	Y+5, r25	; 0x05
     4a4:	ae 83       	std	Y+6, r26	; 0x06
     4a6:	bf 83       	std	Y+7, r27	; 0x07
     4a8:	81 e0       	ldi	r24, 0x01	; 1
     4aa:	03 c0       	rjmp	.+6      	; 0x4b2 <__EEPROM_REGION_LENGTH__+0xb2>
     4ac:	80 e0       	ldi	r24, 0x00	; 0
     4ae:	01 c0       	rjmp	.+2      	; 0x4b2 <__EEPROM_REGION_LENGTH__+0xb2>
     4b0:	80 e0       	ldi	r24, 0x00	; 0
     4b2:	90 e0       	ldi	r25, 0x00	; 0
     4b4:	df 91       	pop	r29
     4b6:	cf 91       	pop	r28
     4b8:	1f 91       	pop	r17
     4ba:	0f 91       	pop	r16
     4bc:	ff 90       	pop	r15
     4be:	ef 90       	pop	r14
     4c0:	df 90       	pop	r13
     4c2:	cf 90       	pop	r12
     4c4:	bf 90       	pop	r11
     4c6:	af 90       	pop	r10
     4c8:	9f 90       	pop	r9
     4ca:	8f 90       	pop	r8
     4cc:	08 95       	ret

000004ce <fseek_>:
     4ce:	cf 92       	push	r12
     4d0:	df 92       	push	r13
     4d2:	ef 92       	push	r14
     4d4:	ff 92       	push	r15
     4d6:	cf 93       	push	r28
     4d8:	df 93       	push	r29
     4da:	21 15       	cp	r18, r1
     4dc:	31 05       	cpc	r19, r1
     4de:	91 f0       	breq	.+36     	; 0x504 <fseek_+0x36>
     4e0:	22 30       	cpi	r18, 0x02	; 2
     4e2:	31 05       	cpc	r19, r1
     4e4:	31 f4       	brne	.+12     	; 0x4f2 <fseek_+0x24>
     4e6:	fc 01       	movw	r30, r24
     4e8:	c4 84       	ldd	r12, Z+12	; 0x0c
     4ea:	d5 84       	ldd	r13, Z+13	; 0x0d
     4ec:	e6 84       	ldd	r14, Z+14	; 0x0e
     4ee:	f7 84       	ldd	r15, Z+15	; 0x0f
     4f0:	10 c0       	rjmp	.+32     	; 0x512 <fseek_+0x44>
     4f2:	21 30       	cpi	r18, 0x01	; 1
     4f4:	31 05       	cpc	r19, r1
     4f6:	51 f4       	brne	.+20     	; 0x50c <fseek_+0x3e>
     4f8:	fc 01       	movw	r30, r24
     4fa:	c0 88       	ldd	r12, Z+16	; 0x10
     4fc:	d1 88       	ldd	r13, Z+17	; 0x11
     4fe:	e2 88       	ldd	r14, Z+18	; 0x12
     500:	f3 88       	ldd	r15, Z+19	; 0x13
     502:	07 c0       	rjmp	.+14     	; 0x512 <fseek_+0x44>
     504:	c1 2c       	mov	r12, r1
     506:	d1 2c       	mov	r13, r1
     508:	76 01       	movw	r14, r12
     50a:	03 c0       	rjmp	.+6      	; 0x512 <fseek_+0x44>
     50c:	c1 2c       	mov	r12, r1
     50e:	d1 2c       	mov	r13, r1
     510:	76 01       	movw	r14, r12
     512:	c4 0e       	add	r12, r20
     514:	d5 1e       	adc	r13, r21
     516:	e6 1e       	adc	r14, r22
     518:	f7 1e       	adc	r15, r23
     51a:	ff 20       	and	r15, r15
     51c:	0c f4       	brge	.+2      	; 0x520 <fseek_+0x52>
     51e:	62 c0       	rjmp	.+196    	; 0x5e4 <fseek_+0x116>
     520:	fc 01       	movw	r30, r24
     522:	44 85       	ldd	r20, Z+12	; 0x0c
     524:	55 85       	ldd	r21, Z+13	; 0x0d
     526:	66 85       	ldd	r22, Z+14	; 0x0e
     528:	77 85       	ldd	r23, Z+15	; 0x0f
     52a:	4c 15       	cp	r20, r12
     52c:	5d 05       	cpc	r21, r13
     52e:	6e 05       	cpc	r22, r14
     530:	7f 05       	cpc	r23, r15
     532:	0c f4       	brge	.+2      	; 0x536 <fseek_+0x68>
     534:	5a c0       	rjmp	.+180    	; 0x5ea <fseek_+0x11c>
     536:	ec 01       	movw	r28, r24
     538:	10 86       	std	Z+8, r1	; 0x08
     53a:	12 86       	std	Z+10, r1	; 0x0a
     53c:	11 86       	std	Z+9, r1	; 0x09
     53e:	10 8a       	std	Z+16, r1	; 0x10
     540:	11 8a       	std	Z+17, r1	; 0x11
     542:	12 8a       	std	Z+18, r1	; 0x12
     544:	13 8a       	std	Z+19, r1	; 0x13
     546:	80 81       	ld	r24, Z
     548:	91 81       	ldd	r25, Z+1	; 0x01
     54a:	a2 81       	ldd	r26, Z+2	; 0x02
     54c:	b3 81       	ldd	r27, Z+3	; 0x03
     54e:	84 83       	std	Z+4, r24	; 0x04
     550:	95 83       	std	Z+5, r25	; 0x05
     552:	a6 83       	std	Z+6, r26	; 0x06
     554:	b7 83       	std	Z+7, r27	; 0x07
     556:	24 c0       	rjmp	.+72     	; 0x5a0 <fseek_+0xd2>
     558:	01 96       	adiw	r24, 0x01	; 1
     55a:	a1 1d       	adc	r26, r1
     55c:	b1 1d       	adc	r27, r1
     55e:	88 8b       	std	Y+16, r24	; 0x10
     560:	99 8b       	std	Y+17, r25	; 0x11
     562:	aa 8b       	std	Y+18, r26	; 0x12
     564:	bb 8b       	std	Y+19, r27	; 0x13
     566:	29 85       	ldd	r18, Y+9	; 0x09
     568:	3a 85       	ldd	r19, Y+10	; 0x0a
     56a:	2f 3f       	cpi	r18, 0xFF	; 255
     56c:	f1 e0       	ldi	r31, 0x01	; 1
     56e:	3f 07       	cpc	r19, r31
     570:	28 f4       	brcc	.+10     	; 0x57c <fseek_+0xae>
     572:	2f 5f       	subi	r18, 0xFF	; 255
     574:	3f 4f       	sbci	r19, 0xFF	; 255
     576:	3a 87       	std	Y+10, r19	; 0x0a
     578:	29 87       	std	Y+9, r18	; 0x09
     57a:	12 c0       	rjmp	.+36     	; 0x5a0 <fseek_+0xd2>
     57c:	1a 86       	std	Y+10, r1	; 0x0a
     57e:	19 86       	std	Y+9, r1	; 0x09
     580:	28 85       	ldd	r18, Y+8	; 0x08
     582:	2f 5f       	subi	r18, 0xFF	; 255
     584:	28 87       	std	Y+8, r18	; 0x08
     586:	30 91 c9 02 	lds	r19, 0x02C9	; 0x8002c9 <SectorsPerCluster>
     58a:	23 17       	cp	r18, r19
     58c:	48 f0       	brcs	.+18     	; 0x5a0 <fseek_+0xd2>
     58e:	84 17       	cp	r24, r20
     590:	95 07       	cpc	r25, r21
     592:	a6 07       	cpc	r26, r22
     594:	b7 07       	cpc	r27, r23
     596:	20 f4       	brcc	.+8      	; 0x5a0 <fseek_+0xd2>
     598:	18 86       	std	Y+8, r1	; 0x08
     59a:	ce 01       	movw	r24, r28
     59c:	0e 94 86 01 	call	0x30c	; 0x30c <GetNextCluster>
     5a0:	88 89       	ldd	r24, Y+16	; 0x10
     5a2:	99 89       	ldd	r25, Y+17	; 0x11
     5a4:	aa 89       	ldd	r26, Y+18	; 0x12
     5a6:	bb 89       	ldd	r27, Y+19	; 0x13
     5a8:	b7 01       	movw	r22, r14
     5aa:	a6 01       	movw	r20, r12
     5ac:	8c 15       	cp	r24, r12
     5ae:	9d 05       	cpc	r25, r13
     5b0:	ae 05       	cpc	r26, r14
     5b2:	bf 05       	cpc	r27, r15
     5b4:	88 f2       	brcs	.-94     	; 0x558 <fseek_+0x8a>
     5b6:	89 85       	ldd	r24, Y+9	; 0x09
     5b8:	9a 85       	ldd	r25, Y+10	; 0x0a
     5ba:	89 2b       	or	r24, r25
     5bc:	c9 f0       	breq	.+50     	; 0x5f0 <fseek_+0x122>
     5be:	8c 81       	ldd	r24, Y+4	; 0x04
     5c0:	9d 81       	ldd	r25, Y+5	; 0x05
     5c2:	ae 81       	ldd	r26, Y+6	; 0x06
     5c4:	bf 81       	ldd	r27, Y+7	; 0x07
     5c6:	28 85       	ldd	r18, Y+8	; 0x08
     5c8:	bc 01       	movw	r22, r24
     5ca:	cd 01       	movw	r24, r26
     5cc:	62 0f       	add	r22, r18
     5ce:	71 1d       	adc	r23, r1
     5d0:	81 1d       	adc	r24, r1
     5d2:	91 1d       	adc	r25, r1
     5d4:	ae 01       	movw	r20, r28
     5d6:	4e 5d       	subi	r20, 0xDE	; 222
     5d8:	5f 4f       	sbci	r21, 0xFF	; 255
     5da:	0e 94 69 0c 	call	0x18d2	; 0x18d2 <SDC_GetSector>
     5de:	80 e0       	ldi	r24, 0x00	; 0
     5e0:	90 e0       	ldi	r25, 0x00	; 0
     5e2:	08 c0       	rjmp	.+16     	; 0x5f4 <fseek_+0x126>
     5e4:	81 e0       	ldi	r24, 0x01	; 1
     5e6:	90 e0       	ldi	r25, 0x00	; 0
     5e8:	05 c0       	rjmp	.+10     	; 0x5f4 <fseek_+0x126>
     5ea:	81 e0       	ldi	r24, 0x01	; 1
     5ec:	90 e0       	ldi	r25, 0x00	; 0
     5ee:	02 c0       	rjmp	.+4      	; 0x5f4 <fseek_+0x126>
     5f0:	80 e0       	ldi	r24, 0x00	; 0
     5f2:	90 e0       	ldi	r25, 0x00	; 0
     5f4:	df 91       	pop	r29
     5f6:	cf 91       	pop	r28
     5f8:	ff 90       	pop	r15
     5fa:	ef 90       	pop	r14
     5fc:	df 90       	pop	r13
     5fe:	cf 90       	pop	r12
     600:	08 95       	ret

00000602 <fgetchar_>:
     602:	cf 92       	push	r12
     604:	df 92       	push	r13
     606:	ef 92       	push	r14
     608:	ff 92       	push	r15
     60a:	0f 93       	push	r16
     60c:	1f 93       	push	r17
     60e:	cf 93       	push	r28
     610:	df 93       	push	r29
     612:	ec 01       	movw	r28, r24
     614:	48 89       	ldd	r20, Y+16	; 0x10
     616:	59 89       	ldd	r21, Y+17	; 0x11
     618:	6a 89       	ldd	r22, Y+18	; 0x12
     61a:	7b 89       	ldd	r23, Y+19	; 0x13
     61c:	4f 5f       	subi	r20, 0xFF	; 255
     61e:	5f 4f       	sbci	r21, 0xFF	; 255
     620:	6f 4f       	sbci	r22, 0xFF	; 255
     622:	7f 4f       	sbci	r23, 0xFF	; 255
     624:	8c 85       	ldd	r24, Y+12	; 0x0c
     626:	9d 85       	ldd	r25, Y+13	; 0x0d
     628:	ae 85       	ldd	r26, Y+14	; 0x0e
     62a:	bf 85       	ldd	r27, Y+15	; 0x0f
     62c:	48 17       	cp	r20, r24
     62e:	59 07       	cpc	r21, r25
     630:	6a 07       	cpc	r22, r26
     632:	7b 07       	cpc	r23, r27
     634:	08 f0       	brcs	.+2      	; 0x638 <fgetchar_+0x36>
     636:	46 c0       	rjmp	.+140    	; 0x6c4 <fgetchar_+0xc2>
     638:	cc 80       	ldd	r12, Y+4	; 0x04
     63a:	dd 80       	ldd	r13, Y+5	; 0x05
     63c:	ee 80       	ldd	r14, Y+6	; 0x06
     63e:	ff 80       	ldd	r15, Y+7	; 0x07
     640:	88 85       	ldd	r24, Y+8	; 0x08
     642:	c8 0e       	add	r12, r24
     644:	d1 1c       	adc	r13, r1
     646:	e1 1c       	adc	r14, r1
     648:	f1 1c       	adc	r15, r1
     64a:	8c 89       	ldd	r24, Y+20	; 0x14
     64c:	9d 89       	ldd	r25, Y+21	; 0x15
     64e:	ae 89       	ldd	r26, Y+22	; 0x16
     650:	bf 89       	ldd	r27, Y+23	; 0x17
     652:	c8 16       	cp	r12, r24
     654:	d9 06       	cpc	r13, r25
     656:	ea 06       	cpc	r14, r26
     658:	fb 06       	cpc	r15, r27
     65a:	59 f0       	breq	.+22     	; 0x672 <fgetchar_+0x70>
     65c:	ae 01       	movw	r20, r28
     65e:	4e 5d       	subi	r20, 0xDE	; 222
     660:	5f 4f       	sbci	r21, 0xFF	; 255
     662:	c7 01       	movw	r24, r14
     664:	b6 01       	movw	r22, r12
     666:	0e 94 69 0c 	call	0x18d2	; 0x18d2 <SDC_GetSector>
     66a:	cc 8a       	std	Y+20, r12	; 0x14
     66c:	dd 8a       	std	Y+21, r13	; 0x15
     66e:	ee 8a       	std	Y+22, r14	; 0x16
     670:	ff 8a       	std	Y+23, r15	; 0x17
     672:	29 85       	ldd	r18, Y+9	; 0x09
     674:	3a 85       	ldd	r19, Y+10	; 0x0a
     676:	fe 01       	movw	r30, r28
     678:	e2 0f       	add	r30, r18
     67a:	f3 1f       	adc	r31, r19
     67c:	02 a1       	ldd	r16, Z+34	; 0x22
     67e:	10 e0       	ldi	r17, 0x00	; 0
     680:	88 89       	ldd	r24, Y+16	; 0x10
     682:	99 89       	ldd	r25, Y+17	; 0x11
     684:	aa 89       	ldd	r26, Y+18	; 0x12
     686:	bb 89       	ldd	r27, Y+19	; 0x13
     688:	01 96       	adiw	r24, 0x01	; 1
     68a:	a1 1d       	adc	r26, r1
     68c:	b1 1d       	adc	r27, r1
     68e:	88 8b       	std	Y+16, r24	; 0x10
     690:	99 8b       	std	Y+17, r25	; 0x11
     692:	aa 8b       	std	Y+18, r26	; 0x12
     694:	bb 8b       	std	Y+19, r27	; 0x13
     696:	2f 3f       	cpi	r18, 0xFF	; 255
     698:	81 e0       	ldi	r24, 0x01	; 1
     69a:	38 07       	cpc	r19, r24
     69c:	28 f4       	brcc	.+10     	; 0x6a8 <fgetchar_+0xa6>
     69e:	2f 5f       	subi	r18, 0xFF	; 255
     6a0:	3f 4f       	sbci	r19, 0xFF	; 255
     6a2:	3a 87       	std	Y+10, r19	; 0x0a
     6a4:	29 87       	std	Y+9, r18	; 0x09
     6a6:	10 c0       	rjmp	.+32     	; 0x6c8 <fgetchar_+0xc6>
     6a8:	1a 86       	std	Y+10, r1	; 0x0a
     6aa:	19 86       	std	Y+9, r1	; 0x09
     6ac:	88 85       	ldd	r24, Y+8	; 0x08
     6ae:	8f 5f       	subi	r24, 0xFF	; 255
     6b0:	88 87       	std	Y+8, r24	; 0x08
     6b2:	90 91 c9 02 	lds	r25, 0x02C9	; 0x8002c9 <SectorsPerCluster>
     6b6:	89 17       	cp	r24, r25
     6b8:	38 f0       	brcs	.+14     	; 0x6c8 <fgetchar_+0xc6>
     6ba:	18 86       	std	Y+8, r1	; 0x08
     6bc:	ce 01       	movw	r24, r28
     6be:	0e 94 86 01 	call	0x30c	; 0x30c <GetNextCluster>
     6c2:	02 c0       	rjmp	.+4      	; 0x6c8 <fgetchar_+0xc6>
     6c4:	0f ef       	ldi	r16, 0xFF	; 255
     6c6:	1f ef       	ldi	r17, 0xFF	; 255
     6c8:	c8 01       	movw	r24, r16
     6ca:	df 91       	pop	r29
     6cc:	cf 91       	pop	r28
     6ce:	1f 91       	pop	r17
     6d0:	0f 91       	pop	r16
     6d2:	ff 90       	pop	r15
     6d4:	ef 90       	pop	r14
     6d6:	df 90       	pop	r13
     6d8:	cf 90       	pop	r12
     6da:	08 95       	ret

000006dc <fread_>:
     6dc:	4f 92       	push	r4
     6de:	5f 92       	push	r5
     6e0:	6f 92       	push	r6
     6e2:	7f 92       	push	r7
     6e4:	8f 92       	push	r8
     6e6:	9f 92       	push	r9
     6e8:	af 92       	push	r10
     6ea:	bf 92       	push	r11
     6ec:	ef 92       	push	r14
     6ee:	ff 92       	push	r15
     6f0:	0f 93       	push	r16
     6f2:	1f 93       	push	r17
     6f4:	cf 93       	push	r28
     6f6:	df 93       	push	r29
     6f8:	00 d0       	rcall	.+0      	; 0x6fa <fread_+0x1e>
     6fa:	00 d0       	rcall	.+0      	; 0x6fc <fread_+0x20>
     6fc:	00 d0       	rcall	.+0      	; 0x6fe <fread_+0x22>
     6fe:	cd b7       	in	r28, 0x3d	; 61
     700:	de b7       	in	r29, 0x3e	; 62
     702:	9e 83       	std	Y+6, r25	; 0x06
     704:	8d 83       	std	Y+5, r24	; 0x05
     706:	4a 01       	movw	r8, r20
     708:	5b 01       	movw	r10, r22
     70a:	09 83       	std	Y+1, r16	; 0x01
     70c:	1a 83       	std	Y+2, r17	; 0x02
     70e:	2b 83       	std	Y+3, r18	; 0x03
     710:	3c 83       	std	Y+4, r19	; 0x04
     712:	41 2c       	mov	r4, r1
     714:	51 2c       	mov	r5, r1
     716:	32 01       	movw	r6, r4
     718:	17 c0       	rjmp	.+46     	; 0x748 <fread_+0x6c>
     71a:	c7 01       	movw	r24, r14
     71c:	0e 94 01 03 	call	0x602	; 0x602 <fgetchar_>
     720:	ad 81       	ldd	r26, Y+5	; 0x05
     722:	be 81       	ldd	r27, Y+6	; 0x06
     724:	8d 93       	st	X+, r24
     726:	be 83       	std	Y+6, r27	; 0x06
     728:	ad 83       	std	Y+5, r26	; 0x05
     72a:	b1 e0       	ldi	r27, 0x01	; 1
     72c:	8b 1a       	sub	r8, r27
     72e:	91 08       	sbc	r9, r1
     730:	a1 08       	sbc	r10, r1
     732:	b1 08       	sbc	r11, r1
     734:	81 14       	cp	r8, r1
     736:	91 04       	cpc	r9, r1
     738:	a1 04       	cpc	r10, r1
     73a:	b1 04       	cpc	r11, r1
     73c:	71 f7       	brne	.-36     	; 0x71a <fread_+0x3e>
     73e:	ef ef       	ldi	r30, 0xFF	; 255
     740:	4e 1a       	sub	r4, r30
     742:	5e 0a       	sbc	r5, r30
     744:	6e 0a       	sbc	r6, r30
     746:	7e 0a       	sbc	r7, r30
     748:	89 81       	ldd	r24, Y+1	; 0x01
     74a:	9a 81       	ldd	r25, Y+2	; 0x02
     74c:	ab 81       	ldd	r26, Y+3	; 0x03
     74e:	bc 81       	ldd	r27, Y+4	; 0x04
     750:	48 16       	cp	r4, r24
     752:	59 06       	cpc	r5, r25
     754:	6a 06       	cpc	r6, r26
     756:	7b 06       	cpc	r7, r27
     758:	68 f3       	brcs	.-38     	; 0x734 <fread_+0x58>
     75a:	c3 01       	movw	r24, r6
     75c:	b2 01       	movw	r22, r4
     75e:	26 96       	adiw	r28, 0x06	; 6
     760:	0f b6       	in	r0, 0x3f	; 63
     762:	f8 94       	cli
     764:	de bf       	out	0x3e, r29	; 62
     766:	0f be       	out	0x3f, r0	; 63
     768:	cd bf       	out	0x3d, r28	; 61
     76a:	df 91       	pop	r29
     76c:	cf 91       	pop	r28
     76e:	1f 91       	pop	r17
     770:	0f 91       	pop	r16
     772:	ff 90       	pop	r15
     774:	ef 90       	pop	r14
     776:	bf 90       	pop	r11
     778:	af 90       	pop	r10
     77a:	9f 90       	pop	r9
     77c:	8f 90       	pop	r8
     77e:	7f 90       	pop	r7
     780:	6f 90       	pop	r6
     782:	5f 90       	pop	r5
     784:	4f 90       	pop	r4
     786:	08 95       	ret

00000788 <FindNextFreeCluster>:
     788:	4f 92       	push	r4
     78a:	5f 92       	push	r5
     78c:	6f 92       	push	r6
     78e:	7f 92       	push	r7
     790:	af 92       	push	r10
     792:	bf 92       	push	r11
     794:	cf 92       	push	r12
     796:	df 92       	push	r13
     798:	ef 92       	push	r14
     79a:	ff 92       	push	r15
     79c:	0f 93       	push	r16
     79e:	1f 93       	push	r17
     7a0:	cf 93       	push	r28
     7a2:	df 93       	push	r29
     7a4:	00 d0       	rcall	.+0      	; 0x7a6 <FindNextFreeCluster+0x1e>
     7a6:	00 d0       	rcall	.+0      	; 0x7a8 <FindNextFreeCluster+0x20>
     7a8:	00 d0       	rcall	.+0      	; 0x7aa <FindNextFreeCluster+0x22>
     7aa:	cd b7       	in	r28, 0x3d	; 61
     7ac:	de b7       	in	r29, 0x3e	; 62
     7ae:	5c 01       	movw	r10, r24
     7b0:	80 91 b8 02 	lds	r24, 0x02B8	; 0x8002b8 <FileAllocationTable>
     7b4:	90 91 b9 02 	lds	r25, 0x02B9	; 0x8002b9 <FileAllocationTable+0x1>
     7b8:	a0 91 ba 02 	lds	r26, 0x02BA	; 0x8002ba <FileAllocationTable+0x2>
     7bc:	b0 91 bb 02 	lds	r27, 0x02BB	; 0x8002bb <FileAllocationTable+0x3>
     7c0:	89 83       	std	Y+1, r24	; 0x01
     7c2:	9a 83       	std	Y+2, r25	; 0x02
     7c4:	ab 83       	std	Y+3, r26	; 0x03
     7c6:	bc 83       	std	Y+4, r27	; 0x04
     7c8:	00 e0       	ldi	r16, 0x00	; 0
     7ca:	10 e0       	ldi	r17, 0x00	; 0
     7cc:	e1 2c       	mov	r14, r1
     7ce:	f1 2c       	mov	r15, r1
     7d0:	51 c0       	rjmp	.+162    	; 0x874 <__stack+0x15>
     7d2:	65 01       	movw	r12, r10
     7d4:	92 e2       	ldi	r25, 0x22	; 34
     7d6:	c9 0e       	add	r12, r25
     7d8:	d1 1c       	adc	r13, r1
     7da:	a6 01       	movw	r20, r12
     7dc:	49 80       	ldd	r4, Y+1	; 0x01
     7de:	5a 80       	ldd	r5, Y+2	; 0x02
     7e0:	6b 80       	ldd	r6, Y+3	; 0x03
     7e2:	7c 80       	ldd	r7, Y+4	; 0x04
     7e4:	4e 0c       	add	r4, r14
     7e6:	5f 1c       	adc	r5, r15
     7e8:	61 1c       	adc	r6, r1
     7ea:	71 1c       	adc	r7, r1
     7ec:	c3 01       	movw	r24, r6
     7ee:	b2 01       	movw	r22, r4
     7f0:	0e 94 69 0c 	call	0x18d2	; 0x18d2 <SDC_GetSector>
     7f4:	d5 01       	movw	r26, r10
     7f6:	54 96       	adiw	r26, 0x14	; 20
     7f8:	4d 92       	st	X+, r4
     7fa:	5d 92       	st	X+, r5
     7fc:	6d 92       	st	X+, r6
     7fe:	7c 92       	st	X, r7
     800:	57 97       	sbiw	r26, 0x17	; 23
     802:	d0 92 f1 04 	sts	0x04F1, r13	; 0x8004f1 <Fat+0x1>
     806:	c0 92 f0 04 	sts	0x04F0, r12	; 0x8004f0 <Fat>
     80a:	1e 82       	std	Y+6, r1	; 0x06
     80c:	1d 82       	std	Y+5, r1	; 0x05
     80e:	29 c0       	rjmp	.+82     	; 0x862 <__stack+0x3>
     810:	e0 91 f0 04 	lds	r30, 0x04F0	; 0x8004f0 <Fat>
     814:	f0 91 f1 04 	lds	r31, 0x04F1	; 0x8004f1 <Fat+0x1>
     818:	8d 81       	ldd	r24, Y+5	; 0x05
     81a:	9e 81       	ldd	r25, Y+6	; 0x06
     81c:	88 0f       	add	r24, r24
     81e:	99 1f       	adc	r25, r25
     820:	e8 0f       	add	r30, r24
     822:	f9 1f       	adc	r31, r25
     824:	80 81       	ld	r24, Z
     826:	91 81       	ldd	r25, Z+1	; 0x01
     828:	89 2b       	or	r24, r25
     82a:	b1 f4       	brne	.+44     	; 0x858 <__DATA_REGION_LENGTH__+0x58>
     82c:	8f ef       	ldi	r24, 0xFF	; 255
     82e:	9f ef       	ldi	r25, 0xFF	; 255
     830:	91 83       	std	Z+1, r25	; 0x01
     832:	80 83       	st	Z, r24
     834:	f5 01       	movw	r30, r10
     836:	64 89       	ldd	r22, Z+20	; 0x14
     838:	75 89       	ldd	r23, Z+21	; 0x15
     83a:	86 89       	ldd	r24, Z+22	; 0x16
     83c:	97 89       	ldd	r25, Z+23	; 0x17
     83e:	a6 01       	movw	r20, r12
     840:	0e 94 e3 0b 	call	0x17c6	; 0x17c6 <SDC_PutSector>
     844:	1e 2d       	mov	r17, r14
     846:	00 27       	eor	r16, r16
     848:	8d 81       	ldd	r24, Y+5	; 0x05
     84a:	9e 81       	ldd	r25, Y+6	; 0x06
     84c:	08 0f       	add	r16, r24
     84e:	19 1f       	adc	r17, r25
     850:	a0 e0       	ldi	r26, 0x00	; 0
     852:	b1 e0       	ldi	r27, 0x01	; 1
     854:	be 83       	std	Y+6, r27	; 0x06
     856:	ad 83       	std	Y+5, r26	; 0x05
     858:	ed 81       	ldd	r30, Y+5	; 0x05
     85a:	fe 81       	ldd	r31, Y+6	; 0x06
     85c:	31 96       	adiw	r30, 0x01	; 1
     85e:	fe 83       	std	Y+6, r31	; 0x06
     860:	ed 83       	std	Y+5, r30	; 0x05
     862:	8d 81       	ldd	r24, Y+5	; 0x05
     864:	9e 81       	ldd	r25, Y+6	; 0x06
     866:	8f 3f       	cpi	r24, 0xFF	; 255
     868:	91 05       	cpc	r25, r1
     86a:	91 f2       	breq	.-92     	; 0x810 <__DATA_REGION_LENGTH__+0x10>
     86c:	88 f2       	brcs	.-94     	; 0x810 <__DATA_REGION_LENGTH__+0x10>
     86e:	9f ef       	ldi	r25, 0xFF	; 255
     870:	e9 1a       	sub	r14, r25
     872:	f9 0a       	sbc	r15, r25
     874:	80 91 c4 02 	lds	r24, 0x02C4	; 0x8002c4 <SectorsPerFat>
     878:	90 91 c5 02 	lds	r25, 0x02C5	; 0x8002c5 <SectorsPerFat+0x1>
     87c:	e8 16       	cp	r14, r24
     87e:	f9 06       	cpc	r15, r25
     880:	20 f4       	brcc	.+8      	; 0x88a <__stack+0x2b>
     882:	01 15       	cp	r16, r1
     884:	11 05       	cpc	r17, r1
     886:	09 f4       	brne	.+2      	; 0x88a <__stack+0x2b>
     888:	a4 cf       	rjmp	.-184    	; 0x7d2 <FindNextFreeCluster+0x4a>
     88a:	c8 01       	movw	r24, r16
     88c:	26 96       	adiw	r28, 0x06	; 6
     88e:	0f b6       	in	r0, 0x3f	; 63
     890:	f8 94       	cli
     892:	de bf       	out	0x3e, r29	; 62
     894:	0f be       	out	0x3f, r0	; 63
     896:	cd bf       	out	0x3d, r28	; 61
     898:	df 91       	pop	r29
     89a:	cf 91       	pop	r28
     89c:	1f 91       	pop	r17
     89e:	0f 91       	pop	r16
     8a0:	ff 90       	pop	r15
     8a2:	ef 90       	pop	r14
     8a4:	df 90       	pop	r13
     8a6:	cf 90       	pop	r12
     8a8:	bf 90       	pop	r11
     8aa:	af 90       	pop	r10
     8ac:	7f 90       	pop	r7
     8ae:	6f 90       	pop	r6
     8b0:	5f 90       	pop	r5
     8b2:	4f 90       	pop	r4
     8b4:	08 95       	ret

000008b6 <SeperateFileName>:
// Description:	This function seperates the filename and the fileattribute and brings them into the needed format ('test.txt' -> 'TEST    TXT');
//				
//________________________________________________________________________________________________________________________________________

void SeperateFileName(s8 *fname, s8 *name)
{
     8b6:	dc 01       	movw	r26, r24
	u8 readpointer	= 0;
	u8 writepointer	= 0;
	u8 attribute	= 1;
     8b8:	81 e0       	ldi	r24, 0x01	; 1
//________________________________________________________________________________________________________________________________________

void SeperateFileName(s8 *fname, s8 *name)
{
	u8 readpointer	= 0;
	u8 writepointer	= 0;
     8ba:	90 e0       	ldi	r25, 0x00	; 0
//				
//________________________________________________________________________________________________________________________________________

void SeperateFileName(s8 *fname, s8 *name)
{
	u8 readpointer	= 0;
     8bc:	30 e0       	ldi	r19, 0x00	; 0
	u8 writepointer	= 0;
	u8 attribute	= 1;
	u8 i = 0;
	
	
	while((writepointer<=10) && (fname[readpointer]!=0))							// the rootdirectoryentry is 8bytes for filename and 3bytes for fileattribute.
     8be:	3a c0       	rjmp	.+116    	; 0x934 <SeperateFileName+0x7e>
	{																				// the filename in the rootdirectory is in the format "TEST    TXT" without the dot.
		if(fname[readpointer]=='.')												// seperating filename and attribute.
     8c0:	2e 32       	cpi	r18, 0x2E	; 46
     8c2:	e1 f4       	brne	.+56     	; 0x8fc <SeperateFileName+0x46>
		{
			if(attribute)															// is the filename "." or ".." ?
     8c4:	88 23       	and	r24, r24
     8c6:	39 f0       	breq	.+14     	; 0x8d6 <SeperateFileName+0x20>
			{
				name[writepointer] = fname[readpointer];
     8c8:	fb 01       	movw	r30, r22
     8ca:	e9 0f       	add	r30, r25
     8cc:	f1 1d       	adc	r31, r1
     8ce:	20 83       	st	Z, r18
				readpointer++;
     8d0:	3f 5f       	subi	r19, 0xFF	; 255
				writepointer++;			
     8d2:	9f 5f       	subi	r25, 0xFF	; 255
     8d4:	2f c0       	rjmp	.+94     	; 0x934 <SeperateFileName+0x7e>
			}
			else
			{
				if(fname[(readpointer-1)] != '*')
     8d6:	4a 0f       	add	r20, r26
     8d8:	5b 1f       	adc	r21, r27
     8da:	fa 01       	movw	r30, r20
     8dc:	31 97       	sbiw	r30, 0x01	; 1
     8de:	20 81       	ld	r18, Z
     8e0:	2a 32       	cpi	r18, 0x2A	; 42
     8e2:	39 f4       	brne	.+14     	; 0x8f2 <SeperateFileName+0x3c>
     8e4:	08 c0       	rjmp	.+16     	; 0x8f6 <SeperateFileName+0x40>
				{
					for(i=writepointer;i<8;i++)
					{
						name[i] = ' ';
     8e6:	fb 01       	movw	r30, r22
     8e8:	e9 0f       	add	r30, r25
     8ea:	f1 1d       	adc	r31, r1
     8ec:	20 e2       	ldi	r18, 0x20	; 32
     8ee:	20 83       	st	Z, r18
			}
			else
			{
				if(fname[(readpointer-1)] != '*')
				{
					for(i=writepointer;i<8;i++)
     8f0:	9f 5f       	subi	r25, 0xFF	; 255
     8f2:	98 30       	cpi	r25, 0x08	; 8
     8f4:	c0 f3       	brcs	.-16     	; 0x8e6 <SeperateFileName+0x30>
					{
						name[i] = ' ';
					}
				}
				readpointer++;
     8f6:	3f 5f       	subi	r19, 0xFF	; 255
				writepointer = 8;
     8f8:	98 e0       	ldi	r25, 0x08	; 8
     8fa:	1c c0       	rjmp	.+56     	; 0x934 <SeperateFileName+0x7e>
			}
		}
		else if(fname[readpointer] == '*')											// wildcard found within the filename + extension.
     8fc:	2a 32       	cpi	r18, 0x2A	; 42
     8fe:	31 f4       	brne	.+12     	; 0x90c <SeperateFileName+0x56>
		{
			if(writepointer < 8)													// in extension.
     900:	98 30       	cpi	r25, 0x08	; 8
     902:	b0 f4       	brcc	.+44     	; 0x930 <SeperateFileName+0x7a>
			{
				readpointer++;
     904:	3f 5f       	subi	r19, 0xFF	; 255
			}
			else																	// in filename.
			{
				writepointer = 11;													// jump to the end of the string to terminate this function.
			}
			attribute = 0;
     906:	80 e0       	ldi	r24, 0x00	; 0
		else if(fname[readpointer] == '*')											// wildcard found within the filename + extension.
		{
			if(writepointer < 8)													// in extension.
			{
				readpointer++;
				writepointer = 8;					
     908:	98 e0       	ldi	r25, 0x08	; 8
     90a:	14 c0       	rjmp	.+40     	; 0x934 <SeperateFileName+0x7e>
			}
			attribute = 0;
		}
		else
		{
			if((fname[readpointer]>96) && (fname[readpointer]<123))
     90c:	8f e9       	ldi	r24, 0x9F	; 159
     90e:	82 0f       	add	r24, r18
     910:	8a 31       	cpi	r24, 0x1A	; 26
     912:	30 f4       	brcc	.+12     	; 0x920 <SeperateFileName+0x6a>
			{
				name[writepointer]=(fname[readpointer] - 32);						// all characters must be upper case.
     914:	fb 01       	movw	r30, r22
     916:	e9 0f       	add	r30, r25
     918:	f1 1d       	adc	r31, r1
     91a:	20 52       	subi	r18, 0x20	; 32
     91c:	20 83       	st	Z, r18
     91e:	04 c0       	rjmp	.+8      	; 0x928 <SeperateFileName+0x72>
			}
			else
			{
				name[writepointer]=fname[readpointer];
     920:	fb 01       	movw	r30, r22
     922:	e9 0f       	add	r30, r25
     924:	f1 1d       	adc	r31, r1
     926:	20 83       	st	Z, r18
			}	
			readpointer++;
     928:	3f 5f       	subi	r19, 0xFF	; 255
			writepointer++;
     92a:	9f 5f       	subi	r25, 0xFF	; 255
			attribute = 0;
     92c:	80 e0       	ldi	r24, 0x00	; 0
     92e:	02 c0       	rjmp	.+4      	; 0x934 <SeperateFileName+0x7e>
			}
			else																	// in filename.
			{
				writepointer = 11;													// jump to the end of the string to terminate this function.
			}
			attribute = 0;
     930:	80 e0       	ldi	r24, 0x00	; 0
				readpointer++;
				writepointer = 8;					
			}
			else																	// in filename.
			{
				writepointer = 11;													// jump to the end of the string to terminate this function.
     932:	9b e0       	ldi	r25, 0x0B	; 11
	u8 writepointer	= 0;
	u8 attribute	= 1;
	u8 i = 0;
	
	
	while((writepointer<=10) && (fname[readpointer]!=0))							// the rootdirectoryentry is 8bytes for filename and 3bytes for fileattribute.
     934:	9b 30       	cpi	r25, 0x0B	; 11
     936:	40 f4       	brcc	.+16     	; 0x948 <SeperateFileName+0x92>
     938:	43 2f       	mov	r20, r19
     93a:	50 e0       	ldi	r21, 0x00	; 0
     93c:	fd 01       	movw	r30, r26
     93e:	e4 0f       	add	r30, r20
     940:	f5 1f       	adc	r31, r21
     942:	20 81       	ld	r18, Z
     944:	21 11       	cpse	r18, r1
     946:	bc cf       	rjmp	.-136    	; 0x8c0 <SeperateFileName+0xa>
     948:	08 95       	ret

0000094a <CreateFileInDirectory>:
//				bit4:	directory
//				bit5:	volume
//________________________________________________________________________________________________________________________________________

u8 CreateFileInDirectory(s8 *fname, File *file)
{
     94a:	3f 92       	push	r3
     94c:	4f 92       	push	r4
     94e:	5f 92       	push	r5
     950:	6f 92       	push	r6
     952:	7f 92       	push	r7
     954:	8f 92       	push	r8
     956:	9f 92       	push	r9
     958:	af 92       	push	r10
     95a:	bf 92       	push	r11
     95c:	cf 92       	push	r12
     95e:	df 92       	push	r13
     960:	ef 92       	push	r14
     962:	ff 92       	push	r15
     964:	0f 93       	push	r16
     966:	1f 93       	push	r17
     968:	cf 93       	push	r28
     96a:	df 93       	push	r29
     96c:	cd b7       	in	r28, 0x3d	; 61
     96e:	de b7       	in	r29, 0x3e	; 62
     970:	2d 97       	sbiw	r28, 0x0d	; 13
     972:	0f b6       	in	r0, 0x3f	; 63
     974:	f8 94       	cli
     976:	de bf       	out	0x3e, r29	; 62
     978:	0f be       	out	0x3f, r0	; 63
     97a:	cd bf       	out	0x3d, r28	; 61
     97c:	6b 01       	movw	r12, r22
	u8 		i = 0;
	u16 	sector_offset = 0;														// index to the sector of the Rootentry which is searched momentarily
	u8 		retvalue = 0;
	u32		cluster_temp = 0;
	u16		cluster = 0;
	s8 name[11] 	= "           ";			
     97e:	2b e0       	ldi	r18, 0x0B	; 11
     980:	ee e6       	ldi	r30, 0x6E	; 110
     982:	f0 e0       	ldi	r31, 0x00	; 0
     984:	de 01       	movw	r26, r28
     986:	11 96       	adiw	r26, 0x01	; 1
     988:	01 90       	ld	r0, Z+
     98a:	0d 92       	st	X+, r0
     98c:	2a 95       	dec	r18
     98e:	e1 f7       	brne	.-8      	; 0x988 <CreateFileInDirectory+0x3e>

	SeperateFileName(fname,name);
     990:	be 01       	movw	r22, r28
     992:	6f 5f       	subi	r22, 0xFF	; 255
     994:	7f 4f       	sbci	r23, 0xFF	; 255
     996:	0e 94 5b 04 	call	0x8b6	; 0x8b6 <SeperateFileName>

	cluster_temp = (u32)FindNextFreeCluster(file);									// the next free cluster on the disk.
     99a:	c6 01       	movw	r24, r12
     99c:	0e 94 c4 03 	call	0x788	; 0x788 <FindNextFreeCluster>
     9a0:	4c 01       	movw	r8, r24
     9a2:	a0 e0       	ldi	r26, 0x00	; 0
     9a4:	b0 e0       	ldi	r27, 0x00	; 0
	
	if(cluster_temp) 																// if a free cluster is available:
     9a6:	00 97       	sbiw	r24, 0x00	; 0
     9a8:	a1 05       	cpc	r26, r1
     9aa:	b1 05       	cpc	r27, r1
     9ac:	09 f4       	brne	.+2      	; 0x9b0 <CreateFileInDirectory+0x66>
     9ae:	bd c0       	rjmp	.+378    	; 0xb2a <CreateFileInDirectory+0x1e0>
	{
		cluster = (u16)cluster_temp;												// remember the index of the free datacluster found for the directory entry.
		cluster_temp -=2;															// Clusterposition is ((position in FAT)-2). first two entries in FAT are reserved.
     9b0:	9c 01       	movw	r18, r24
     9b2:	ad 01       	movw	r20, r26
     9b4:	22 50       	subi	r18, 0x02	; 2
     9b6:	31 09       	sbc	r19, r1
     9b8:	41 09       	sbc	r20, r1
     9ba:	51 09       	sbc	r21, r1
		cluster_temp *= SectorsPerCluster;											// Calculate relative sectorindex of first datacluster.
     9bc:	a0 91 c9 02 	lds	r26, 0x02C9	; 0x8002c9 <SectorsPerCluster>
     9c0:	b0 e0       	ldi	r27, 0x00	; 0
     9c2:	0e 94 de 0c 	call	0x19bc	; 0x19bc <__muluhisi3>
		file->start_cluster   = (FirstDataCluster + cluster_temp);					// Calculate absolute sectorposition of first datacluster.
     9c6:	00 91 b0 02 	lds	r16, 0x02B0	; 0x8002b0 <FirstDataCluster>
     9ca:	10 91 b1 02 	lds	r17, 0x02B1	; 0x8002b1 <FirstDataCluster+0x1>
     9ce:	20 91 b2 02 	lds	r18, 0x02B2	; 0x8002b2 <FirstDataCluster+0x2>
     9d2:	30 91 b3 02 	lds	r19, 0x02B3	; 0x8002b3 <FirstDataCluster+0x3>
     9d6:	dc 01       	movw	r26, r24
     9d8:	cb 01       	movw	r24, r22
     9da:	80 0f       	add	r24, r16
     9dc:	91 1f       	adc	r25, r17
     9de:	a2 1f       	adc	r26, r18
     9e0:	b3 1f       	adc	r27, r19
     9e2:	f6 01       	movw	r30, r12
     9e4:	80 83       	st	Z, r24
     9e6:	91 83       	std	Z+1, r25	; 0x01
     9e8:	a2 83       	std	Z+2, r26	; 0x02
     9ea:	b3 83       	std	Z+3, r27	; 0x03
		file->cluster_pointer = file->start_cluster;								// start reading the file with the first sector of the first datacluster.
     9ec:	84 83       	std	Z+4, r24	; 0x04
     9ee:	95 83       	std	Z+5, r25	; 0x05
     9f0:	a6 83       	std	Z+6, r26	; 0x06
     9f2:	b7 83       	std	Z+7, r27	; 0x07
{
	u16 	rootentry	= 0;														// index to an entry in the rootdirectory.
	u16 	cnt_enries_searched = 0;												// count the number of rootentries which have been searched already.
	u8 		i = 0;
	u16 	sector_offset = 0;														// index to the sector of the Rootentry which is searched momentarily
	u8 		retvalue = 0;
     9f4:	31 2c       	mov	r3, r1
u8 CreateFileInDirectory(s8 *fname, File *file)
{
	u16 	rootentry	= 0;														// index to an entry in the rootdirectory.
	u16 	cnt_enries_searched = 0;												// count the number of rootentries which have been searched already.
	u8 		i = 0;
	u16 	sector_offset = 0;														// index to the sector of the Rootentry which is searched momentarily
     9f6:	1d 86       	std	Y+13, r1	; 0x0d
     9f8:	1c 86       	std	Y+12, r1	; 0x0c
//________________________________________________________________________________________________________________________________________

u8 CreateFileInDirectory(s8 *fname, File *file)
{
	u16 	rootentry	= 0;														// index to an entry in the rootdirectory.
	u16 	cnt_enries_searched = 0;												// count the number of rootentries which have been searched already.
     9fa:	e1 2c       	mov	r14, r1
     9fc:	f1 2c       	mov	r15, r1
	
																					// directory starts at sector specified by dir_sector. This can be the rootdirectory or any other directory.
		do
		{																			// search the next 16 rootentries in this sector of the roordirectory.
			rootentry=0;									
			SDC_GetSector((u32)(CWD + sector_offset),file->buffer);				// Read the Rootdirectory.
     9fe:	56 01       	movw	r10, r12
     a00:	f2 e2       	ldi	r31, 0x22	; 34
     a02:	af 0e       	add	r10, r31
     a04:	b1 1c       	adc	r11, r1
     a06:	8c 85       	ldd	r24, Y+12	; 0x0c
     a08:	9d 85       	ldd	r25, Y+13	; 0x0d
     a0a:	2c 01       	movw	r4, r24
     a0c:	61 2c       	mov	r6, r1
     a0e:	71 2c       	mov	r7, r1
     a10:	80 91 ac 02 	lds	r24, 0x02AC	; 0x8002ac <__data_end>
     a14:	90 91 ad 02 	lds	r25, 0x02AD	; 0x8002ad <__data_end+0x1>
     a18:	a0 91 ae 02 	lds	r26, 0x02AE	; 0x8002ae <__data_end+0x2>
     a1c:	b0 91 af 02 	lds	r27, 0x02AF	; 0x8002af <__data_end+0x3>
     a20:	bc 01       	movw	r22, r24
     a22:	cd 01       	movw	r24, r26
     a24:	64 0d       	add	r22, r4
     a26:	75 1d       	adc	r23, r5
     a28:	86 1d       	adc	r24, r6
     a2a:	97 1d       	adc	r25, r7
     a2c:	a5 01       	movw	r20, r10
     a2e:	0e 94 69 0c 	call	0x18d2	; 0x18d2 <SDC_GetSector>
			DirectoryEntry = (struct DirEntry *)file->buffer;
     a32:	b0 92 cc 02 	sts	0x02CC, r11	; 0x8002cc <DirectoryEntry+0x1>
     a36:	a0 92 cb 02 	sts	0x02CB, r10	; 0x8002cb <DirectoryEntry>
		file->cluster_pointer = file->start_cluster;								// start reading the file with the first sector of the first datacluster.
	
																					// directory starts at sector specified by dir_sector. This can be the rootdirectory or any other directory.
		do
		{																			// search the next 16 rootentries in this sector of the roordirectory.
			rootentry=0;									
     a3a:	00 e0       	ldi	r16, 0x00	; 0
     a3c:	10 e0       	ldi	r17, 0x00	; 0
			SDC_GetSector((u32)(CWD + sector_offset),file->buffer);				// Read the Rootdirectory.
			DirectoryEntry = (struct DirEntry *)file->buffer;
			while((rootentry<16) && (!retvalue))
     a3e:	5d c0       	rjmp	.+186    	; 0xafa <CreateFileInDirectory+0x1b0>
			{
				if((DirectoryEntry[rootentry].attribute == 0) || (DirectoryEntry[rootentry].attribute == 0xE5))	// empty directory entry found
     a40:	a8 01       	movw	r20, r16
     a42:	44 0f       	add	r20, r20
     a44:	55 1f       	adc	r21, r21
     a46:	42 95       	swap	r20
     a48:	52 95       	swap	r21
     a4a:	50 7f       	andi	r21, 0xF0	; 240
     a4c:	54 27       	eor	r21, r20
     a4e:	40 7f       	andi	r20, 0xF0	; 240
     a50:	54 27       	eor	r21, r20
     a52:	e0 91 cb 02 	lds	r30, 0x02CB	; 0x8002cb <DirectoryEntry>
     a56:	f0 91 cc 02 	lds	r31, 0x02CC	; 0x8002cc <DirectoryEntry+0x1>
     a5a:	e4 0f       	add	r30, r20
     a5c:	f5 1f       	adc	r31, r21
     a5e:	83 85       	ldd	r24, Z+11	; 0x0b
     a60:	88 23       	and	r24, r24
     a62:	d1 f0       	breq	.+52     	; 0xa98 <CreateFileInDirectory+0x14e>
     a64:	85 3e       	cpi	r24, 0xE5	; 229
     a66:	09 f0       	breq	.+2      	; 0xa6a <CreateFileInDirectory+0x120>
     a68:	43 c0       	rjmp	.+134    	; 0xaf0 <CreateFileInDirectory+0x1a6>
     a6a:	18 c0       	rjmp	.+48     	; 0xa9c <CreateFileInDirectory+0x152>
				{
					for(i=0;i<11;i++) DirectoryEntry[rootentry].name[i] = name[i];// Kopie the filename and the file extension to the directoryentry.
     a6c:	80 91 cb 02 	lds	r24, 0x02CB	; 0x8002cb <DirectoryEntry>
     a70:	90 91 cc 02 	lds	r25, 0x02CC	; 0x8002cc <DirectoryEntry+0x1>
     a74:	9c 01       	movw	r18, r24
     a76:	24 0f       	add	r18, r20
     a78:	35 1f       	adc	r19, r21
     a7a:	86 2f       	mov	r24, r22
     a7c:	90 e0       	ldi	r25, 0x00	; 0
     a7e:	e1 e0       	ldi	r30, 0x01	; 1
     a80:	f0 e0       	ldi	r31, 0x00	; 0
     a82:	ec 0f       	add	r30, r28
     a84:	fd 1f       	adc	r31, r29
     a86:	e8 0f       	add	r30, r24
     a88:	f9 1f       	adc	r31, r25
     a8a:	70 81       	ld	r23, Z
     a8c:	f9 01       	movw	r30, r18
     a8e:	e8 0f       	add	r30, r24
     a90:	f9 1f       	adc	r31, r25
     a92:	70 83       	st	Z, r23
     a94:	6f 5f       	subi	r22, 0xFF	; 255
     a96:	03 c0       	rjmp	.+6      	; 0xa9e <CreateFileInDirectory+0x154>
     a98:	60 e0       	ldi	r22, 0x00	; 0
     a9a:	01 c0       	rjmp	.+2      	; 0xa9e <CreateFileInDirectory+0x154>
     a9c:	60 e0       	ldi	r22, 0x00	; 0
     a9e:	6b 30       	cpi	r22, 0x0B	; 11
     aa0:	28 f3       	brcs	.-54     	; 0xa6c <CreateFileInDirectory+0x122>
					DirectoryEntry[rootentry].attribute    = _FILE;					// Set the fileattribute to archive to reserve the directoryentry.
     aa2:	e0 91 cb 02 	lds	r30, 0x02CB	; 0x8002cb <DirectoryEntry>
     aa6:	f0 91 cc 02 	lds	r31, 0x02CC	; 0x8002cc <DirectoryEntry+0x1>
     aaa:	e4 0f       	add	r30, r20
     aac:	f5 1f       	adc	r31, r21
     aae:	80 e2       	ldi	r24, 0x20	; 32
     ab0:	83 87       	std	Z+11, r24	; 0x0b
					DirectoryEntry[rootentry].startcluster = cluster;				// copy the location of the first datacluster to the directoryentry.
     ab2:	93 8e       	std	Z+27, r9	; 0x1b
     ab4:	82 8e       	std	Z+26, r8	; 0x1a
					DirectoryEntry[rootentry].size     = 0;							// the new createted file has no content yet.
     ab6:	14 8e       	std	Z+28, r1	; 0x1c
     ab8:	15 8e       	std	Z+29, r1	; 0x1d
     aba:	16 8e       	std	Z+30, r1	; 0x1e
     abc:	17 8e       	std	Z+31, r1	; 0x1f
					file->directory_sector = (u32) (CWD + sector_offset);
     abe:	80 91 ac 02 	lds	r24, 0x02AC	; 0x8002ac <__data_end>
     ac2:	90 91 ad 02 	lds	r25, 0x02AD	; 0x8002ad <__data_end+0x1>
     ac6:	a0 91 ae 02 	lds	r26, 0x02AE	; 0x8002ae <__data_end+0x2>
     aca:	b0 91 af 02 	lds	r27, 0x02AF	; 0x8002af <__data_end+0x3>
     ace:	bc 01       	movw	r22, r24
     ad0:	cd 01       	movw	r24, r26
     ad2:	64 0d       	add	r22, r4
     ad4:	75 1d       	adc	r23, r5
     ad6:	86 1d       	adc	r24, r6
     ad8:	97 1d       	adc	r25, r7
     ada:	f6 01       	movw	r30, r12
     adc:	64 8f       	std	Z+28, r22	; 0x1c
     ade:	75 8f       	std	Z+29, r23	; 0x1d
     ae0:	86 8f       	std	Z+30, r24	; 0x1e
     ae2:	97 8f       	std	Z+31, r25	; 0x1f
					file->directory_index  = (u8) rootentry;
     ae4:	00 a3       	std	Z+32, r16	; 0x20
					retvalue = 1;
					SDC_PutSector((u32)(CWD + sector_offset),file->buffer);				
     ae6:	a5 01       	movw	r20, r10
     ae8:	0e 94 e3 0b 	call	0x17c6	; 0x17c6 <SDC_PutSector>
					DirectoryEntry[rootentry].attribute    = _FILE;					// Set the fileattribute to archive to reserve the directoryentry.
					DirectoryEntry[rootentry].startcluster = cluster;				// copy the location of the first datacluster to the directoryentry.
					DirectoryEntry[rootentry].size     = 0;							// the new createted file has no content yet.
					file->directory_sector = (u32) (CWD + sector_offset);
					file->directory_index  = (u8) rootentry;
					retvalue = 1;
     aec:	33 24       	eor	r3, r3
     aee:	33 94       	inc	r3
					SDC_PutSector((u32)(CWD + sector_offset),file->buffer);				
				}			
				rootentry++;
     af0:	0f 5f       	subi	r16, 0xFF	; 255
     af2:	1f 4f       	sbci	r17, 0xFF	; 255
				cnt_enries_searched++;
     af4:	ff ef       	ldi	r31, 0xFF	; 255
     af6:	ef 1a       	sub	r14, r31
     af8:	ff 0a       	sbc	r15, r31
		do
		{																			// search the next 16 rootentries in this sector of the roordirectory.
			rootentry=0;									
			SDC_GetSector((u32)(CWD + sector_offset),file->buffer);				// Read the Rootdirectory.
			DirectoryEntry = (struct DirEntry *)file->buffer;
			while((rootentry<16) && (!retvalue))
     afa:	00 31       	cpi	r16, 0x10	; 16
     afc:	11 05       	cpc	r17, r1
     afe:	18 f4       	brcc	.+6      	; 0xb06 <CreateFileInDirectory+0x1bc>
     b00:	33 20       	and	r3, r3
     b02:	09 f4       	brne	.+2      	; 0xb06 <CreateFileInDirectory+0x1bc>
     b04:	9d cf       	rjmp	.-198    	; 0xa40 <CreateFileInDirectory+0xf6>
					SDC_PutSector((u32)(CWD + sector_offset),file->buffer);				
				}			
				rootentry++;
				cnt_enries_searched++;
			}
			if(!retvalue)															// file not found in this sector so take next sector.
     b06:	31 10       	cpse	r3, r1
     b08:	05 c0       	rjmp	.+10     	; 0xb14 <CreateFileInDirectory+0x1ca>
			{
				rootentry = 0;
				sector_offset++;
     b0a:	8c 85       	ldd	r24, Y+12	; 0x0c
     b0c:	9d 85       	ldd	r25, Y+13	; 0x0d
     b0e:	01 96       	adiw	r24, 0x01	; 1
     b10:	9d 87       	std	Y+13, r25	; 0x0d
     b12:	8c 87       	std	Y+12, r24	; 0x0c
			}
		}
		while((cnt_enries_searched< PossibleRootEntries) && (!retvalue));
     b14:	80 91 c6 02 	lds	r24, 0x02C6	; 0x8002c6 <PossibleRootEntries>
     b18:	90 91 c7 02 	lds	r25, 0x02C7	; 0x8002c7 <PossibleRootEntries+0x1>
     b1c:	e8 16       	cp	r14, r24
     b1e:	f9 06       	cpc	r15, r25
     b20:	28 f4       	brcc	.+10     	; 0xb2c <CreateFileInDirectory+0x1e2>
     b22:	33 20       	and	r3, r3
     b24:	09 f4       	brne	.+2      	; 0xb28 <CreateFileInDirectory+0x1de>
     b26:	6b cf       	rjmp	.-298    	; 0x9fe <CreateFileInDirectory+0xb4>
     b28:	01 c0       	rjmp	.+2      	; 0xb2c <CreateFileInDirectory+0x1e2>
{
	u16 	rootentry	= 0;														// index to an entry in the rootdirectory.
	u16 	cnt_enries_searched = 0;												// count the number of rootentries which have been searched already.
	u8 		i = 0;
	u16 	sector_offset = 0;														// index to the sector of the Rootentry which is searched momentarily
	u8 		retvalue = 0;
     b2a:	31 2c       	mov	r3, r1
		}
		while((cnt_enries_searched< PossibleRootEntries) && (!retvalue));

	}
	return(retvalue);																// return 1 if file has been created otherwise return 0.
}
     b2c:	83 2d       	mov	r24, r3
     b2e:	2d 96       	adiw	r28, 0x0d	; 13
     b30:	0f b6       	in	r0, 0x3f	; 63
     b32:	f8 94       	cli
     b34:	de bf       	out	0x3e, r29	; 62
     b36:	0f be       	out	0x3f, r0	; 63
     b38:	cd bf       	out	0x3d, r28	; 61
     b3a:	df 91       	pop	r29
     b3c:	cf 91       	pop	r28
     b3e:	1f 91       	pop	r17
     b40:	0f 91       	pop	r16
     b42:	ff 90       	pop	r15
     b44:	ef 90       	pop	r14
     b46:	df 90       	pop	r13
     b48:	cf 90       	pop	r12
     b4a:	bf 90       	pop	r11
     b4c:	af 90       	pop	r10
     b4e:	9f 90       	pop	r9
     b50:	8f 90       	pop	r8
     b52:	7f 90       	pop	r7
     b54:	6f 90       	pop	r6
     b56:	5f 90       	pop	r5
     b58:	4f 90       	pop	r4
     b5a:	3f 90       	pop	r3
     b5c:	08 95       	ret

00000b5e <SeekFileInDirectory>:
//				
// Returnvalue: This function returns 1 if the directoryentry specified was found.
//________________________________________________________________________________________________________________________________________

u8 SeekFileInDirectory(s8 *fname, File *file)
{
     b5e:	6f 92       	push	r6
     b60:	7f 92       	push	r7
     b62:	8f 92       	push	r8
     b64:	9f 92       	push	r9
     b66:	af 92       	push	r10
     b68:	bf 92       	push	r11
     b6a:	cf 92       	push	r12
     b6c:	df 92       	push	r13
     b6e:	ef 92       	push	r14
     b70:	ff 92       	push	r15
     b72:	0f 93       	push	r16
     b74:	1f 93       	push	r17
     b76:	cf 93       	push	r28
     b78:	df 93       	push	r29
     b7a:	cd b7       	in	r28, 0x3d	; 61
     b7c:	de b7       	in	r29, 0x3e	; 62
     b7e:	2b 97       	sbiw	r28, 0x0b	; 11
     b80:	0f b6       	in	r0, 0x3f	; 63
     b82:	f8 94       	cli
     b84:	de bf       	out	0x3e, r29	; 62
     b86:	0f be       	out	0x3f, r0	; 63
     b88:	cd bf       	out	0x3d, r28	; 61
     b8a:	8b 01       	movw	r16, r22
	u16 	rootentry=0;
	u16   	end_of_directory_not_reached = 0;										// the directory has been read completely without a result.
	u8 		i=0;
	u8  	retvalue = 0;
	u32  	cluster_temp = 0;
	s8 name[11] 	= "           ";			
     b8c:	2b e0       	ldi	r18, 0x0B	; 11
     b8e:	ee e6       	ldi	r30, 0x6E	; 110
     b90:	f0 e0       	ldi	r31, 0x00	; 0
     b92:	de 01       	movw	r26, r28
     b94:	11 96       	adiw	r26, 0x01	; 1
     b96:	01 90       	ld	r0, Z+
     b98:	0d 92       	st	X+, r0
     b9a:	2a 95       	dec	r18
     b9c:	e1 f7       	brne	.-8      	; 0xb96 <SeekFileInDirectory+0x38>
	
	SeperateFileName(fname,name);
     b9e:	be 01       	movw	r22, r28
     ba0:	6f 5f       	subi	r22, 0xFF	; 255
     ba2:	7f 4f       	sbci	r23, 0xFF	; 255
     ba4:	0e 94 5b 04 	call	0x8b6	; 0x8b6 <SeperateFileName>
	
	file->cluster_pointer = CWD;													// start looking for the file in the actual directory.
     ba8:	80 91 ac 02 	lds	r24, 0x02AC	; 0x8002ac <__data_end>
     bac:	90 91 ad 02 	lds	r25, 0x02AD	; 0x8002ad <__data_end+0x1>
     bb0:	a0 91 ae 02 	lds	r26, 0x02AE	; 0x8002ae <__data_end+0x2>
     bb4:	b0 91 af 02 	lds	r27, 0x02AF	; 0x8002af <__data_end+0x3>
     bb8:	f8 01       	movw	r30, r16
     bba:	84 83       	std	Z+4, r24	; 0x04
     bbc:	95 83       	std	Z+5, r25	; 0x05
     bbe:	a6 83       	std	Z+6, r26	; 0x06
     bc0:	b7 83       	std	Z+7, r27	; 0x07
u8 SeekFileInDirectory(s8 *fname, File *file)
{
	u16 	rootentry=0;
	u16   	end_of_directory_not_reached = 0;										// the directory has been read completely without a result.
	u8 		i=0;
	u8  	retvalue = 0;
     bc2:	b1 2c       	mov	r11, r1
//________________________________________________________________________________________________________________________________________

u8 SeekFileInDirectory(s8 *fname, File *file)
{
	u16 	rootentry=0;
	u16   	end_of_directory_not_reached = 0;										// the directory has been read completely without a result.
     bc4:	e1 2c       	mov	r14, r1
     bc6:	f1 2c       	mov	r15, r1

																					// directory starts at sector specified by dir_sector. This can be the rootdirectory or any other directory.
	do
	{																				// search the next 16 rootentries in this sector of the roordirectory.
		rootentry=0;									
		SDC_GetSector((u32) file->cluster_pointer,file->buffer);					// Read the Rootdirectory.
     bc8:	f8 01       	movw	r30, r16
     bca:	64 81       	ldd	r22, Z+4	; 0x04
     bcc:	75 81       	ldd	r23, Z+5	; 0x05
     bce:	86 81       	ldd	r24, Z+6	; 0x06
     bd0:	97 81       	ldd	r25, Z+7	; 0x07
     bd2:	68 01       	movw	r12, r16
     bd4:	f2 e2       	ldi	r31, 0x22	; 34
     bd6:	cf 0e       	add	r12, r31
     bd8:	d1 1c       	adc	r13, r1
     bda:	a6 01       	movw	r20, r12
     bdc:	0e 94 69 0c 	call	0x18d2	; 0x18d2 <SDC_GetSector>
		DirectoryEntry = (struct DirEntry *)file->buffer;
     be0:	d0 92 cc 02 	sts	0x02CC, r13	; 0x8002cc <DirectoryEntry+0x1>
     be4:	c0 92 cb 02 	sts	0x02CB, r12	; 0x8002cb <DirectoryEntry>
	file->cluster_pointer = CWD;													// start looking for the file in the actual directory.

																					// directory starts at sector specified by dir_sector. This can be the rootdirectory or any other directory.
	do
	{																				// search the next 16 rootentries in this sector of the roordirectory.
		rootentry=0;									
     be8:	61 2c       	mov	r6, r1
     bea:	71 2c       	mov	r7, r1
		SDC_GetSector((u32) file->cluster_pointer,file->buffer);					// Read the Rootdirectory.
		DirectoryEntry = (struct DirEntry *)file->buffer;

		while((!retvalue)&&(rootentry<16))
     bec:	81 c0       	rjmp	.+258    	; 0xcf0 <SeekFileInDirectory+0x192>
		{
			i=0;
			if(DirectoryEntry[rootentry].name[0] != 0xe5)							// ignore deleted items.
     bee:	63 01       	movw	r12, r6
     bf0:	cc 0c       	add	r12, r12
     bf2:	dd 1c       	adc	r13, r13
     bf4:	cc 0c       	add	r12, r12
     bf6:	dd 1c       	adc	r13, r13
     bf8:	cc 0c       	add	r12, r12
     bfa:	dd 1c       	adc	r13, r13
     bfc:	cc 0c       	add	r12, r12
     bfe:	dd 1c       	adc	r13, r13
     c00:	cc 0c       	add	r12, r12
     c02:	dd 1c       	adc	r13, r13
     c04:	a0 91 cb 02 	lds	r26, 0x02CB	; 0x8002cb <DirectoryEntry>
     c08:	b0 91 cc 02 	lds	r27, 0x02CC	; 0x8002cc <DirectoryEntry+0x1>
     c0c:	ac 0d       	add	r26, r12
     c0e:	bd 1d       	adc	r27, r13
     c10:	8c 91       	ld	r24, X
     c12:	85 3e       	cpi	r24, 0xE5	; 229
     c14:	21 f4       	brne	.+8      	; 0xc1e <SeekFileInDirectory+0xc0>
		SDC_GetSector((u32) file->cluster_pointer,file->buffer);					// Read the Rootdirectory.
		DirectoryEntry = (struct DirEntry *)file->buffer;

		while((!retvalue)&&(rootentry<16))
		{
			i=0;
     c16:	20 e0       	ldi	r18, 0x00	; 0
     c18:	1b c0       	rjmp	.+54     	; 0xc50 <SeekFileInDirectory+0xf2>
			if(DirectoryEntry[rootentry].name[0] != 0xe5)							// ignore deleted items.
			{
				while((i<=10)&&(DirectoryEntry[rootentry].name[i] == name[i]))
				{
					i++;
     c1a:	2f 5f       	subi	r18, 0xFF	; 255
     c1c:	01 c0       	rjmp	.+2      	; 0xc20 <SeekFileInDirectory+0xc2>
     c1e:	20 e0       	ldi	r18, 0x00	; 0
		while((!retvalue)&&(rootentry<16))
		{
			i=0;
			if(DirectoryEntry[rootentry].name[0] != 0xe5)							// ignore deleted items.
			{
				while((i<=10)&&(DirectoryEntry[rootentry].name[i] == name[i]))
     c20:	2b 30       	cpi	r18, 0x0B	; 11
     c22:	b0 f4       	brcc	.+44     	; 0xc50 <SeekFileInDirectory+0xf2>
     c24:	82 2f       	mov	r24, r18
     c26:	90 e0       	ldi	r25, 0x00	; 0
     c28:	ad 01       	movw	r20, r26
     c2a:	48 0f       	add	r20, r24
     c2c:	59 1f       	adc	r21, r25
     c2e:	fa 01       	movw	r30, r20
     c30:	40 81       	ld	r20, Z
     c32:	50 e0       	ldi	r21, 0x00	; 0
     c34:	61 e0       	ldi	r22, 0x01	; 1
     c36:	70 e0       	ldi	r23, 0x00	; 0
     c38:	6c 0f       	add	r22, r28
     c3a:	7d 1f       	adc	r23, r29
     c3c:	86 0f       	add	r24, r22
     c3e:	97 1f       	adc	r25, r23
     c40:	fc 01       	movw	r30, r24
     c42:	80 81       	ld	r24, Z
     c44:	08 2e       	mov	r0, r24
     c46:	00 0c       	add	r0, r0
     c48:	99 0b       	sbc	r25, r25
     c4a:	48 17       	cp	r20, r24
     c4c:	59 07       	cpc	r21, r25
     c4e:	29 f3       	breq	.-54     	; 0xc1a <SeekFileInDirectory+0xbc>
				{
					i++;
				}
			}

			if((i==11) && (DirectoryEntry[rootentry].attribute & _FILE))			// entry found!! -> reading startcluster of entry from offset 26.
     c50:	2b 30       	cpi	r18, 0x0B	; 11
     c52:	09 f0       	breq	.+2      	; 0xc56 <SeekFileInDirectory+0xf8>
     c54:	4a c0       	rjmp	.+148    	; 0xcea <SeekFileInDirectory+0x18c>
     c56:	1b 96       	adiw	r26, 0x0b	; 11
     c58:	8c 91       	ld	r24, X
     c5a:	1b 97       	sbiw	r26, 0x0b	; 11
     c5c:	85 ff       	sbrs	r24, 5
     c5e:	45 c0       	rjmp	.+138    	; 0xcea <SeekFileInDirectory+0x18c>
			{
				cluster_temp = (u32)DirectoryEntry[rootentry].startcluster; 							
     c60:	5a 96       	adiw	r26, 0x1a	; 26
     c62:	2d 91       	ld	r18, X+
     c64:	3c 91       	ld	r19, X
     c66:	5b 97       	sbiw	r26, 0x1b	; 27
     c68:	c9 01       	movw	r24, r18
     c6a:	a0 e0       	ldi	r26, 0x00	; 0
     c6c:	b0 e0       	ldi	r27, 0x00	; 0
				cluster_temp -=2;													// Clusterposition is ((position in FAT)-2). first two entries in FAT are reserved.
     c6e:	9c 01       	movw	r18, r24
     c70:	ad 01       	movw	r20, r26
     c72:	22 50       	subi	r18, 0x02	; 2
     c74:	31 09       	sbc	r19, r1
     c76:	41 09       	sbc	r20, r1
     c78:	51 09       	sbc	r21, r1
				cluster_temp *= (u32)SectorsPerCluster;								// Calculate positon of first cluster.
     c7a:	a0 91 c9 02 	lds	r26, 0x02C9	; 0x8002c9 <SectorsPerCluster>
     c7e:	b0 e0       	ldi	r27, 0x00	; 0
     c80:	0e 94 de 0c 	call	0x19bc	; 0x19bc <__muluhisi3>
				file->start_cluster   = (FirstDataCluster + cluster_temp);
     c84:	80 90 b0 02 	lds	r8, 0x02B0	; 0x8002b0 <FirstDataCluster>
     c88:	90 90 b1 02 	lds	r9, 0x02B1	; 0x8002b1 <FirstDataCluster+0x1>
     c8c:	a0 90 b2 02 	lds	r10, 0x02B2	; 0x8002b2 <FirstDataCluster+0x2>
     c90:	b0 90 b3 02 	lds	r11, 0x02B3	; 0x8002b3 <FirstDataCluster+0x3>
     c94:	dc 01       	movw	r26, r24
     c96:	cb 01       	movw	r24, r22
     c98:	88 0d       	add	r24, r8
     c9a:	99 1d       	adc	r25, r9
     c9c:	aa 1d       	adc	r26, r10
     c9e:	bb 1d       	adc	r27, r11
     ca0:	f8 01       	movw	r30, r16
     ca2:	80 83       	st	Z, r24
     ca4:	91 83       	std	Z+1, r25	; 0x01
     ca6:	a2 83       	std	Z+2, r26	; 0x02
     ca8:	b3 83       	std	Z+3, r27	; 0x03
				file->directory_sector = (u32) file->cluster_pointer;
     caa:	84 80       	ldd	r8, Z+4	; 0x04
     cac:	95 80       	ldd	r9, Z+5	; 0x05
     cae:	a6 80       	ldd	r10, Z+6	; 0x06
     cb0:	b7 80       	ldd	r11, Z+7	; 0x07
     cb2:	84 8e       	std	Z+28, r8	; 0x1c
     cb4:	95 8e       	std	Z+29, r9	; 0x1d
     cb6:	a6 8e       	std	Z+30, r10	; 0x1e
     cb8:	b7 8e       	std	Z+31, r11	; 0x1f
				file->cluster_pointer = file->start_cluster;						// start reading the file with the first cluster.
     cba:	84 83       	std	Z+4, r24	; 0x04
     cbc:	95 83       	std	Z+5, r25	; 0x05
     cbe:	a6 83       	std	Z+6, r26	; 0x06
     cc0:	b7 83       	std	Z+7, r27	; 0x07
				file->filesize = (u32) DirectoryEntry[rootentry].size;
     cc2:	80 91 cb 02 	lds	r24, 0x02CB	; 0x8002cb <DirectoryEntry>
     cc6:	90 91 cc 02 	lds	r25, 0x02CC	; 0x8002cc <DirectoryEntry+0x1>
     cca:	dc 01       	movw	r26, r24
     ccc:	ac 0d       	add	r26, r12
     cce:	bd 1d       	adc	r27, r13
     cd0:	5c 96       	adiw	r26, 0x1c	; 28
     cd2:	8d 91       	ld	r24, X+
     cd4:	9d 91       	ld	r25, X+
     cd6:	0d 90       	ld	r0, X+
     cd8:	bc 91       	ld	r27, X
     cda:	a0 2d       	mov	r26, r0
     cdc:	84 87       	std	Z+12, r24	; 0x0c
     cde:	95 87       	std	Z+13, r25	; 0x0d
     ce0:	a6 87       	std	Z+14, r26	; 0x0e
     ce2:	b7 87       	std	Z+15, r27	; 0x0f
				file->directory_index  = (u8) rootentry;
     ce4:	60 a2       	std	Z+32, r6	; 0x20
				retvalue = 1;
     ce6:	bb 24       	eor	r11, r11
     ce8:	b3 94       	inc	r11
			}
			rootentry++;
     cea:	ff ef       	ldi	r31, 0xFF	; 255
     cec:	6f 1a       	sub	r6, r31
     cee:	7f 0a       	sbc	r7, r31
	{																				// search the next 16 rootentries in this sector of the roordirectory.
		rootentry=0;									
		SDC_GetSector((u32) file->cluster_pointer,file->buffer);					// Read the Rootdirectory.
		DirectoryEntry = (struct DirEntry *)file->buffer;

		while((!retvalue)&&(rootentry<16))
     cf0:	b1 10       	cpse	r11, r1
     cf2:	05 c0       	rjmp	.+10     	; 0xcfe <SeekFileInDirectory+0x1a0>
     cf4:	20 e1       	ldi	r18, 0x10	; 16
     cf6:	62 16       	cp	r6, r18
     cf8:	71 04       	cpc	r7, r1
     cfa:	08 f4       	brcc	.+2      	; 0xcfe <SeekFileInDirectory+0x1a0>
     cfc:	78 cf       	rjmp	.-272    	; 0xbee <SeekFileInDirectory+0x90>
				file->directory_index  = (u8) rootentry;
				retvalue = 1;
			}
			rootentry++;
		}
		if(!retvalue)																// file not found in this sector so take next sector.
     cfe:	b1 10       	cpse	r11, r1
     d00:	04 c0       	rjmp	.+8      	; 0xd0a <SeekFileInDirectory+0x1ac>
		{
			end_of_directory_not_reached = GetNextCluster(file);
     d02:	c8 01       	movw	r24, r16
     d04:	0e 94 86 01 	call	0x30c	; 0x30c <GetNextCluster>
     d08:	7c 01       	movw	r14, r24
		}
	}
	while((end_of_directory_not_reached) && (!retvalue));
     d0a:	e1 14       	cp	r14, r1
     d0c:	f1 04       	cpc	r15, r1
     d0e:	19 f0       	breq	.+6      	; 0xd16 <SeekFileInDirectory+0x1b8>
     d10:	bb 20       	and	r11, r11
     d12:	09 f4       	brne	.+2      	; 0xd16 <SeekFileInDirectory+0x1b8>
     d14:	59 cf       	rjmp	.-334    	; 0xbc8 <SeekFileInDirectory+0x6a>
	return(retvalue);
}
     d16:	8b 2d       	mov	r24, r11
     d18:	2b 96       	adiw	r28, 0x0b	; 11
     d1a:	0f b6       	in	r0, 0x3f	; 63
     d1c:	f8 94       	cli
     d1e:	de bf       	out	0x3e, r29	; 62
     d20:	0f be       	out	0x3f, r0	; 63
     d22:	cd bf       	out	0x3d, r28	; 61
     d24:	df 91       	pop	r29
     d26:	cf 91       	pop	r28
     d28:	1f 91       	pop	r17
     d2a:	0f 91       	pop	r16
     d2c:	ff 90       	pop	r15
     d2e:	ef 90       	pop	r14
     d30:	df 90       	pop	r13
     d32:	cf 90       	pop	r12
     d34:	bf 90       	pop	r11
     d36:	af 90       	pop	r10
     d38:	9f 90       	pop	r9
     d3a:	8f 90       	pop	r8
     d3c:	7f 90       	pop	r7
     d3e:	6f 90       	pop	r6
     d40:	08 95       	ret

00000d42 <ReserveFilePointer>:
{
	File *file;
	file = NULL;
	u8	temp;
	
	for(temp = 0;temp<__MAX_FILES_USED;temp++)
     d42:	80 e0       	ldi	r24, 0x00	; 0
     d44:	3f c0       	rjmp	.+126    	; 0xdc4 <ReserveFilePointer+0x82>
	{
		if(FilePointer[temp].state == _UNUSED)										// free filepointer found?
     d46:	28 2f       	mov	r18, r24
     d48:	30 e0       	ldi	r19, 0x00	; 0
     d4a:	43 e2       	ldi	r20, 0x23	; 35
     d4c:	52 e0       	ldi	r21, 0x02	; 2
     d4e:	24 9f       	mul	r18, r20
     d50:	f0 01       	movw	r30, r0
     d52:	25 9f       	mul	r18, r21
     d54:	f0 0d       	add	r31, r0
     d56:	34 9f       	mul	r19, r20
     d58:	f0 0d       	add	r31, r0
     d5a:	11 24       	eor	r1, r1
     d5c:	e1 51       	subi	r30, 0x11	; 17
     d5e:	fb 4f       	sbci	r31, 0xFB	; 251
     d60:	90 81       	ld	r25, Z
     d62:	91 30       	cpi	r25, 0x01	; 1
     d64:	71 f5       	brne	.+92     	; 0xdc2 <ReserveFilePointer+0x80>
		{
			file = &FilePointer[temp];
     d66:	24 9f       	mul	r18, r20
     d68:	c0 01       	movw	r24, r0
     d6a:	25 9f       	mul	r18, r21
     d6c:	90 0d       	add	r25, r0
     d6e:	34 9f       	mul	r19, r20
     d70:	90 0d       	add	r25, r0
     d72:	11 24       	eor	r1, r1
     d74:	83 53       	subi	r24, 0x33	; 51
     d76:	9d 4f       	sbci	r25, 0xFD	; 253
			FilePointer[temp].state 				= _USED;						// mark as used.
     d78:	fc 01       	movw	r30, r24
     d7a:	ee 5d       	subi	r30, 0xDE	; 222
     d7c:	fd 4f       	sbci	r31, 0xFD	; 253
     d7e:	22 e0       	ldi	r18, 0x02	; 2
     d80:	20 83       	st	Z, r18
			FilePointer[temp].mode 					= 0;							// type of access (read/write) not defined yet.
     d82:	fc 01       	movw	r30, r24
     d84:	13 86       	std	Z+11, r1	; 0x0b
			FilePointer[temp].start_cluster			= 0;							// Sectorpointer to the first sector of the first datacluster of the file. 
     d86:	10 82       	st	Z, r1
     d88:	11 82       	std	Z+1, r1	; 0x01
     d8a:	12 82       	std	Z+2, r1	; 0x02
     d8c:	13 82       	std	Z+3, r1	; 0x03
			FilePointer[temp].cluster_pointer		= 0;							// Pointer to the cluster which is edited at the moment.
     d8e:	14 82       	std	Z+4, r1	; 0x04
     d90:	15 82       	std	Z+5, r1	; 0x05
     d92:	16 82       	std	Z+6, r1	; 0x06
     d94:	17 82       	std	Z+7, r1	; 0x07
			FilePointer[temp].sector_index 			= 0;							// The sector which is edited at the moment (cluster_pointer + sector_index).
     d96:	10 86       	std	Z+8, r1	; 0x08
			FilePointer[temp].byte_index 			= 0;							// The bytelocation within the current sector (cluster_pointer + sector_index + byte_index).
     d98:	12 86       	std	Z+10, r1	; 0x0a
     d9a:	11 86       	std	Z+9, r1	; 0x09
			FilePointer[temp].filesize 				= 0;							// the size of the opend file in bytes.
     d9c:	14 86       	std	Z+12, r1	; 0x0c
     d9e:	15 86       	std	Z+13, r1	; 0x0d
     da0:	16 86       	std	Z+14, r1	; 0x0e
     da2:	17 86       	std	Z+15, r1	; 0x0f
			FilePointer[temp].fileposition 			= 0;							// pointer to a character within the file 0 < fileposition < filesize
     da4:	10 8a       	std	Z+16, r1	; 0x10
     da6:	11 8a       	std	Z+17, r1	; 0x11
     da8:	12 8a       	std	Z+18, r1	; 0x12
     daa:	13 8a       	std	Z+19, r1	; 0x13
			FilePointer[temp].sector_in_buffer 		= 0;							// the last sector read, wich is still in the sectorbuffer.
     dac:	14 8a       	std	Z+20, r1	; 0x14
     dae:	15 8a       	std	Z+21, r1	; 0x15
     db0:	16 8a       	std	Z+22, r1	; 0x16
     db2:	17 8a       	std	Z+23, r1	; 0x17
			FilePointer[temp].directory_sector 		= 0;							// the sectorposition where the directoryentry has been made.
     db4:	14 8e       	std	Z+28, r1	; 0x1c
     db6:	15 8e       	std	Z+29, r1	; 0x1d
     db8:	16 8e       	std	Z+30, r1	; 0x1e
     dba:	17 8e       	std	Z+31, r1	; 0x1f
			FilePointer[temp].directory_index 		= 0;							// the index to the directoryentry within the specified sector.
     dbc:	10 a2       	std	Z+32, r1	; 0x20
			FilePointer[temp].attribute 			= 0;							// the attribute of the file opened.
     dbe:	11 a2       	std	Z+33, r1	; 0x21
			break;
     dc0:	08 95       	ret
{
	File *file;
	file = NULL;
	u8	temp;
	
	for(temp = 0;temp<__MAX_FILES_USED;temp++)
     dc2:	8f 5f       	subi	r24, 0xFF	; 255
     dc4:	88 23       	and	r24, r24
     dc6:	09 f4       	brne	.+2      	; 0xdca <ReserveFilePointer+0x88>
     dc8:	be cf       	rjmp	.-132    	; 0xd46 <ReserveFilePointer+0x4>
//________________________________________________________________________________________________________________________________________

File * ReserveFilePointer(void)
{
	File *file;
	file = NULL;
     dca:	80 e0       	ldi	r24, 0x00	; 0
     dcc:	90 e0       	ldi	r25, 0x00	; 0
			FilePointer[temp].attribute 			= 0;							// the attribute of the file opened.
			break;
		}
	}
	return(file);
}
     dce:	08 95       	ret

00000dd0 <FreeFilePointer>:
//	Return:		none
// 				
//________________________________________________________________________________________________________________________________________

void FreeFilePointer(File *file)
{
     dd0:	bc 01       	movw	r22, r24
	u8 cnt = 0;
	
	for(cnt=0;cnt<__MAX_FILES_USED;cnt++)											// Is the filepointeradress vaild?
     dd2:	90 e0       	ldi	r25, 0x00	; 0
     dd4:	1e c0       	rjmp	.+60     	; 0xe12 <FreeFilePointer+0x42>
	{
		if(&FilePointer[cnt] == file)												// filepointer found therefore it must be valid
     dd6:	49 2f       	mov	r20, r25
     dd8:	50 e0       	ldi	r21, 0x00	; 0
     dda:	e3 e2       	ldi	r30, 0x23	; 35
     ddc:	f2 e0       	ldi	r31, 0x02	; 2
     dde:	4e 9f       	mul	r20, r30
     de0:	90 01       	movw	r18, r0
     de2:	4f 9f       	mul	r20, r31
     de4:	30 0d       	add	r19, r0
     de6:	5e 9f       	mul	r21, r30
     de8:	30 0d       	add	r19, r0
     dea:	11 24       	eor	r1, r1
     dec:	23 53       	subi	r18, 0x33	; 51
     dee:	3d 4f       	sbci	r19, 0xFD	; 253
     df0:	26 17       	cp	r18, r22
     df2:	37 07       	cpc	r19, r23
     df4:	69 f4       	brne	.+26     	; 0xe10 <FreeFilePointer+0x40>
		{
			FilePointer[cnt].state = _UNUSED;										// and can be marked as unused.
     df6:	23 e2       	ldi	r18, 0x23	; 35
     df8:	32 e0       	ldi	r19, 0x02	; 2
     dfa:	42 9f       	mul	r20, r18
     dfc:	f0 01       	movw	r30, r0
     dfe:	43 9f       	mul	r20, r19
     e00:	f0 0d       	add	r31, r0
     e02:	52 9f       	mul	r21, r18
     e04:	f0 0d       	add	r31, r0
     e06:	11 24       	eor	r1, r1
     e08:	e1 51       	subi	r30, 0x11	; 17
     e0a:	fb 4f       	sbci	r31, 0xFB	; 251
     e0c:	81 e0       	ldi	r24, 0x01	; 1
     e0e:	80 83       	st	Z, r24

void FreeFilePointer(File *file)
{
	u8 cnt = 0;
	
	for(cnt=0;cnt<__MAX_FILES_USED;cnt++)											// Is the filepointeradress vaild?
     e10:	9f 5f       	subi	r25, 0xFF	; 255
     e12:	99 23       	and	r25, r25
     e14:	01 f3       	breq	.-64     	; 0xdd6 <FreeFilePointer+0x6>
		if(&FilePointer[cnt] == file)												// filepointer found therefore it must be valid
		{
			FilePointer[cnt].state = _UNUSED;										// and can be marked as unused.
		}
	}
}
     e16:	08 95       	ret

00000e18 <fopen_>:
//	Return:		Pointer to the opened file or NULL
//				
//________________________________________________________________________________________________________________________________________

File * fopen_(s8 *fname, s8 mode)
{
     e18:	ef 92       	push	r14
     e1a:	ff 92       	push	r15
     e1c:	1f 93       	push	r17
     e1e:	cf 93       	push	r28
     e20:	df 93       	push	r29
     e22:	7c 01       	movw	r14, r24
     e24:	16 2f       	mov	r17, r22
	File *file;
	
	file = ReserveFilePointer();													// reserve a filepointer.	
     e26:	0e 94 a1 06 	call	0xd42	; 0xd42 <ReserveFilePointer>
     e2a:	ec 01       	movw	r28, r24
	
	if(file != NULL)																// A free filepointer was found.
     e2c:	00 97       	sbiw	r24, 0x00	; 0
     e2e:	39 f1       	breq	.+78     	; 0xe7e <fopen_+0x66>
	{
		file->mode 	= mode;															// mode of fileoperation (read,write)
     e30:	1b 87       	std	Y+11, r17	; 0x0b

		if(SeekFileInDirectory(fname, file))										// if file was found
     e32:	bc 01       	movw	r22, r24
     e34:	c7 01       	movw	r24, r14
     e36:	0e 94 af 05 	call	0xb5e	; 0xb5e <SeekFileInDirectory>
     e3a:	88 23       	and	r24, r24
     e3c:	59 f0       	breq	.+22     	; 0xe54 <fopen_+0x3c>
		{
			if(mode == 'a')															// open existing file for writing (append data at the end of the file)
     e3e:	11 36       	cpi	r17, 0x61	; 97
     e40:	f1 f4       	brne	.+60     	; 0xe7e <fopen_+0x66>
			{	
				fseek_(file, 0, SEEK_END);											// fseek points to the end of the file
     e42:	22 e0       	ldi	r18, 0x02	; 2
     e44:	30 e0       	ldi	r19, 0x00	; 0
     e46:	40 e0       	ldi	r20, 0x00	; 0
     e48:	50 e0       	ldi	r21, 0x00	; 0
     e4a:	ba 01       	movw	r22, r20
     e4c:	ce 01       	movw	r24, r28
     e4e:	0e 94 67 02 	call	0x4ce	; 0x4ce <fseek_>
     e52:	15 c0       	rjmp	.+42     	; 0xe7e <fopen_+0x66>
			}
		}		
		else
		{
			if((mode == 'a') || (mode == 'w'))										// specified file doesn't exist so create new file for writing data.
     e54:	11 36       	cpi	r17, 0x61	; 97
     e56:	11 f0       	breq	.+4      	; 0xe5c <fopen_+0x44>
     e58:	17 37       	cpi	r17, 0x77	; 119
     e5a:	61 f4       	brne	.+24     	; 0xe74 <fopen_+0x5c>
			{	
				if(CreateFileInDirectory(fname,file))								// Could an entry for the new file in the rootdirectory be created?
     e5c:	be 01       	movw	r22, r28
     e5e:	c7 01       	movw	r24, r14
     e60:	0e 94 a5 04 	call	0x94a	; 0x94a <CreateFileInDirectory>
     e64:	81 11       	cpse	r24, r1
     e66:	0b c0       	rjmp	.+22     	; 0xe7e <fopen_+0x66>
				{
					return(file);
				}	
				else
				{
					FreeFilePointer(file);										    // free the filepointer.
     e68:	ce 01       	movw	r24, r28
     e6a:	0e 94 e8 06 	call	0xdd0	; 0xdd0 <FreeFilePointer>
					file = NULL;
     e6e:	c0 e0       	ldi	r28, 0x00	; 0
     e70:	d0 e0       	ldi	r29, 0x00	; 0
		}		
		else
		{
			if((mode == 'a') || (mode == 'w'))										// specified file doesn't exist so create new file for writing data.
			{	
				if(CreateFileInDirectory(fname,file))								// Could an entry for the new file in the rootdirectory be created?
     e72:	05 c0       	rjmp	.+10     	; 0xe7e <fopen_+0x66>
					file = NULL;
				}
			}
            else                                                                    // file with mode 'r' not found
            {
            	FreeFilePointer(file);												// free the filepointer.
     e74:	ce 01       	movw	r24, r28
     e76:	0e 94 e8 06 	call	0xdd0	; 0xdd0 <FreeFilePointer>
                file = NULL;                                                        // file not found
     e7a:	c0 e0       	ldi	r28, 0x00	; 0
     e7c:	d0 e0       	ldi	r29, 0x00	; 0
            }
		}
	}
	return(file);
}
     e7e:	ce 01       	movw	r24, r28
     e80:	df 91       	pop	r29
     e82:	cf 91       	pop	r28
     e84:	1f 91       	pop	r17
     e86:	ff 90       	pop	r15
     e88:	ef 90       	pop	r14
     e8a:	08 95       	ret

00000e8c <fclose_>:
// Description:	This function closes the open file by writing the remaining data from the buffer to the device and entering the filesize 
//				in the directory entry.
//________________________________________________________________________________________________________________________________________

void fclose_(File *file)
{
     e8c:	cf 93       	push	r28
     e8e:	df 93       	push	r29
     e90:	ec 01       	movw	r28, r24

	if(file != NULL)
     e92:	00 97       	sbiw	r24, 0x00	; 0
     e94:	11 f0       	breq	.+4      	; 0xe9a <fclose_+0xe>
	{
		fflush_(file);																		// save buffered data to the disk
     e96:	0e 94 26 01 	call	0x24c	; 0x24c <fflush_>
	}
	FreeFilePointer(file);																	// and free the filepointer.
     e9a:	ce 01       	movw	r24, r28
     e9c:	0e 94 e8 06 	call	0xdd0	; 0xdd0 <FreeFilePointer>
}
     ea0:	df 91       	pop	r29
     ea2:	cf 91       	pop	r28
     ea4:	08 95       	ret

00000ea6 <hd44780_outnibble>:
static void
hd44780_outnibble(uint8_t n, uint8_t rs)
{
  uint8_t x;

  HD44780_PORTOUTc &= ~_BV(HD44780_RW);
     ea6:	9b b3       	in	r25, 0x1b	; 27
     ea8:	9f 7b       	andi	r25, 0xBF	; 191
     eaa:	9b bb       	out	0x1b, r25	; 27
  if (rs)
     eac:	66 23       	and	r22, r22
     eae:	21 f0       	breq	.+8      	; 0xeb8 <hd44780_outnibble+0x12>
    HD44780_PORTOUTc |= _BV(HD44780_RS);
     eb0:	9b b3       	in	r25, 0x1b	; 27
     eb2:	90 68       	ori	r25, 0x80	; 128
     eb4:	9b bb       	out	0x1b, r25	; 27
     eb6:	03 c0       	rjmp	.+6      	; 0xebe <hd44780_outnibble+0x18>
  else
    HD44780_PORTOUTc &= ~_BV(HD44780_RS);
     eb8:	9b b3       	in	r25, 0x1b	; 27
     eba:	9f 77       	andi	r25, 0x7F	; 127
     ebc:	9b bb       	out	0x1b, r25	; 27
  x = (HD44780_PORTOUT & ~HD44780_DATABITS) | ( n & HD44780_DATABITS);
     ebe:	92 b3       	in	r25, 0x12	; 18
     ec0:	9f 70       	andi	r25, 0x0F	; 15
     ec2:	80 7f       	andi	r24, 0xF0	; 240
     ec4:	89 2b       	or	r24, r25
  HD44780_PORTOUT = x;
     ec6:	82 bb       	out	0x12, r24	; 18
 */
static inline void
hd44780_pulse_e(void)
{

  HD44780_PORTOUTc |= _BV(HD44780_E);
     ec8:	8b b3       	in	r24, 0x1b	; 27
     eca:	80 62       	ori	r24, 0x20	; 32
     ecc:	8b bb       	out	0x1b, r24	; 27
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     ece:	00 c0       	rjmp	.+0      	; 0xed0 <hd44780_outnibble+0x2a>
     ed0:	00 c0       	rjmp	.+0      	; 0xed2 <hd44780_outnibble+0x2c>
#if F_CPU > 4000000UL
  _delay_us(0.5);		/* guarantee 500 ns high */
#elif F_CPU > 2000000UL
  __asm__ volatile("nop");
#endif
  HD44780_PORTOUTc &= ~_BV(HD44780_E);
     ed2:	8b b3       	in	r24, 0x1b	; 27
     ed4:	8f 7d       	andi	r24, 0xDF	; 223
     ed6:	8b bb       	out	0x1b, r24	; 27
     ed8:	08 95       	ret

00000eda <hd44780_innibble>:
static uint8_t
hd44780_innibble(uint8_t rs)
{
  uint8_t x;

  HD44780_PORTOUTc |= _BV(HD44780_RW);
     eda:	9b b3       	in	r25, 0x1b	; 27
     edc:	90 64       	ori	r25, 0x40	; 64
     ede:	9b bb       	out	0x1b, r25	; 27
  HD44780_DDR &= ~HD44780_DATABITS;
     ee0:	91 b3       	in	r25, 0x11	; 17
     ee2:	9f 70       	andi	r25, 0x0F	; 15
     ee4:	91 bb       	out	0x11, r25	; 17
  if (rs)
     ee6:	88 23       	and	r24, r24
     ee8:	21 f0       	breq	.+8      	; 0xef2 <hd44780_innibble+0x18>
    HD44780_PORTOUTc |= _BV(HD44780_RS);
     eea:	8b b3       	in	r24, 0x1b	; 27
     eec:	80 68       	ori	r24, 0x80	; 128
     eee:	8b bb       	out	0x1b, r24	; 27
     ef0:	03 c0       	rjmp	.+6      	; 0xef8 <hd44780_innibble+0x1e>
  else
    HD44780_PORTOUTc &= ~_BV(HD44780_RS);
     ef2:	8b b3       	in	r24, 0x1b	; 27
     ef4:	8f 77       	andi	r24, 0x7F	; 127
     ef6:	8b bb       	out	0x1b, r24	; 27
 */
static inline void
hd44780_pulse_e(void)
{

  HD44780_PORTOUTc |= _BV(HD44780_E);
     ef8:	8b b3       	in	r24, 0x1b	; 27
     efa:	80 62       	ori	r24, 0x20	; 32
     efc:	8b bb       	out	0x1b, r24	; 27
     efe:	00 c0       	rjmp	.+0      	; 0xf00 <hd44780_innibble+0x26>
     f00:	00 c0       	rjmp	.+0      	; 0xf02 <hd44780_innibble+0x28>
#if F_CPU > 4000000UL
  _delay_us(0.5);		/* guarantee 500 ns high */
#elif F_CPU > 2000000UL
  __asm__ volatile("nop");
#endif
  HD44780_PORTOUTc &= ~_BV(HD44780_E);
     f02:	8b b3       	in	r24, 0x1b	; 27
     f04:	8f 7d       	andi	r24, 0xDF	; 223
     f06:	8b bb       	out	0x1b, r24	; 27
  if (rs)
    HD44780_PORTOUTc |= _BV(HD44780_RS);
  else
    HD44780_PORTOUTc &= ~_BV(HD44780_RS);
  hd44780_pulse_e();
  x = (HD44780_PORTIN & HD44780_DATABITS);
     f08:	80 b3       	in	r24, 0x10	; 16
  HD44780_DDR |= HD44780_DATABITS;
     f0a:	91 b3       	in	r25, 0x11	; 17
     f0c:	90 6f       	ori	r25, 0xF0	; 240
     f0e:	91 bb       	out	0x11, r25	; 17
  HD44780_PORTOUTc &= ~_BV(HD44780_RW);
     f10:	9b b3       	in	r25, 0x1b	; 27
     f12:	9f 7b       	andi	r25, 0xBF	; 191
     f14:	9b bb       	out	0x1b, r25	; 27

  return (x & HD44780_DATABITS);
}
     f16:	80 7f       	andi	r24, 0xF0	; 240
     f18:	08 95       	ret

00000f1a <hd44780_outbyte>:
 * Send one byte to the LCD controller.  As we are in 4-bit mode, we
 * have to send two nibbles : MSB first.
 */
void
hd44780_outbyte(uint8_t b, uint8_t rs)
{
     f1a:	cf 93       	push	r28
     f1c:	df 93       	push	r29
     f1e:	c8 2f       	mov	r28, r24
     f20:	d6 2f       	mov	r29, r22
  hd44780_outnibble(((b & 0xF0)>>(4-RANG_LSB)), rs);  //envoi des 4bits MSB de b sur les 4 bits MSB du PORT!!!!!
     f22:	80 7f       	andi	r24, 0xF0	; 240
     f24:	0e 94 53 07 	call	0xea6	; 0xea6 <hd44780_outnibble>
  hd44780_outnibble((b<<RANG_LSB) , rs);  //puis envoi des 4bits LSB de b  sur les 4 bits MSB du PORT!!!!!
     f28:	6d 2f       	mov	r22, r29
     f2a:	8c 2f       	mov	r24, r28
     f2c:	82 95       	swap	r24
     f2e:	80 7f       	andi	r24, 0xF0	; 240
     f30:	0e 94 53 07 	call	0xea6	; 0xea6 <hd44780_outnibble>
}
     f34:	df 91       	pop	r29
     f36:	cf 91       	pop	r28
     f38:	08 95       	ret

00000f3a <hd44780_inbyte>:
/*
 * Read one byte (i.e. two nibbles : MSB first ) from the LCD controller.
 */
uint8_t
hd44780_inbyte(uint8_t rs)
{
     f3a:	cf 93       	push	r28
     f3c:	df 93       	push	r29
     f3e:	c8 2f       	mov	r28, r24
  uint8_t x;

  x = hd44780_innibble(rs<<(4-RANG_LSB)) ;  //lecture des 4bits MSB  du PORT!!!!
     f40:	0e 94 6d 07 	call	0xeda	; 0xeda <hd44780_innibble>
     f44:	d8 2f       	mov	r29, r24
  x |= hd44780_innibble(rs)>>RANG_LSB; //puis lecture des 4bits  stocks MSB  du PORT rangs sur les LSB  de x !!!!
     f46:	8c 2f       	mov	r24, r28
     f48:	0e 94 6d 07 	call	0xeda	; 0xeda <hd44780_innibble>
     f4c:	82 95       	swap	r24
     f4e:	8f 70       	andi	r24, 0x0F	; 15

  return x;
}
     f50:	8d 2b       	or	r24, r29
     f52:	df 91       	pop	r29
     f54:	cf 91       	pop	r28
     f56:	08 95       	ret

00000f58 <hd44780_wait_ready>:
 * Wait until the busy flag is cleared.
 */
void
hd44780_wait_ready(void)
{
  while (hd44780_incmd() & HD44780_BUSYFLAG) ;
     f58:	80 e0       	ldi	r24, 0x00	; 0
     f5a:	0e 94 9d 07 	call	0xf3a	; 0xf3a <hd44780_inbyte>
     f5e:	88 23       	and	r24, r24
     f60:	dc f3       	brlt	.-10     	; 0xf58 <hd44780_wait_ready>
}
     f62:	08 95       	ret

00000f64 <hd44780_init>:
 */
void
hd44780_init(void)
{

  HD44780_DDR =HD44780_DDR |  HD44780_DATABITS;
     f64:	81 b3       	in	r24, 0x11	; 17
     f66:	80 6f       	ori	r24, 0xF0	; 240
     f68:	81 bb       	out	0x11, r24	; 17
  HD44780_DDRc =HD44780_DDRc | _BV(HD44780_RS) | _BV(HD44780_RW) | _BV(HD44780_E);
     f6a:	8a b3       	in	r24, 0x1a	; 26
     f6c:	80 6e       	ori	r24, 0xE0	; 224
     f6e:	8a bb       	out	0x1a, r24	; 26
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     f70:	8f e2       	ldi	r24, 0x2F	; 47
     f72:	95 e7       	ldi	r25, 0x75	; 117
     f74:	01 97       	sbiw	r24, 0x01	; 1
     f76:	f1 f7       	brne	.-4      	; 0xf74 <hd44780_init+0x10>
     f78:	00 c0       	rjmp	.+0      	; 0xf7a <hd44780_init+0x16>
     f7a:	00 00       	nop
  _delay_ms(15);		/* 40 ms needed for Vcc = 2.7 V */
  hd44780_outnibble(HD44780_FNSET(1, 0, 0) >> 4, 0);
     f7c:	60 e0       	ldi	r22, 0x00	; 0
     f7e:	83 e0       	ldi	r24, 0x03	; 3
     f80:	0e 94 53 07 	call	0xea6	; 0xea6 <hd44780_outnibble>
     f84:	87 e0       	ldi	r24, 0x07	; 7
     f86:	90 e2       	ldi	r25, 0x20	; 32
     f88:	01 97       	sbiw	r24, 0x01	; 1
     f8a:	f1 f7       	brne	.-4      	; 0xf88 <hd44780_init+0x24>
     f8c:	00 c0       	rjmp	.+0      	; 0xf8e <hd44780_init+0x2a>
     f8e:	00 00       	nop
  _delay_ms(4.1);
  hd44780_outnibble(HD44780_FNSET(1, 0, 0) >> 4, 0);
     f90:	60 e0       	ldi	r22, 0x00	; 0
     f92:	83 e0       	ldi	r24, 0x03	; 3
     f94:	0e 94 53 07 	call	0xea6	; 0xea6 <hd44780_outnibble>
     f98:	87 ec       	ldi	r24, 0xC7	; 199
     f9a:	90 e0       	ldi	r25, 0x00	; 0
     f9c:	01 97       	sbiw	r24, 0x01	; 1
     f9e:	f1 f7       	brne	.-4      	; 0xf9c <hd44780_init+0x38>
     fa0:	00 c0       	rjmp	.+0      	; 0xfa2 <hd44780_init+0x3e>
     fa2:	00 00       	nop
  _delay_ms(0.1);
  hd44780_outnibble(HD44780_FNSET(1, 0, 0) >> 4, 0);
     fa4:	60 e0       	ldi	r22, 0x00	; 0
     fa6:	83 e0       	ldi	r24, 0x03	; 3
     fa8:	0e 94 53 07 	call	0xea6	; 0xea6 <hd44780_outnibble>
     fac:	87 e0       	ldi	r24, 0x07	; 7
     fae:	90 e2       	ldi	r25, 0x20	; 32
     fb0:	01 97       	sbiw	r24, 0x01	; 1
     fb2:	f1 f7       	brne	.-4      	; 0xfb0 <hd44780_init+0x4c>
     fb4:	00 c0       	rjmp	.+0      	; 0xfb6 <hd44780_init+0x52>
     fb6:	00 00       	nop
  _delay_ms(4.1);
  hd44780_outnibble(HD44780_FNSET(0, 1, 0) >> 4, 0);
     fb8:	60 e0       	ldi	r22, 0x00	; 0
     fba:	82 e0       	ldi	r24, 0x02	; 2
     fbc:	0e 94 53 07 	call	0xea6	; 0xea6 <hd44780_outnibble>
  hd44780_wait_ready();//_delay_ms(15);//
     fc0:	0e 94 ac 07 	call	0xf58	; 0xf58 <hd44780_wait_ready>
  hd44780_outcmd(HD44780_FNSET(0, 1, 0));
     fc4:	60 e0       	ldi	r22, 0x00	; 0
     fc6:	88 e2       	ldi	r24, 0x28	; 40
     fc8:	0e 94 8d 07 	call	0xf1a	; 0xf1a <hd44780_outbyte>
  hd44780_wait_ready();//_delay_ms(15);//
     fcc:	0e 94 ac 07 	call	0xf58	; 0xf58 <hd44780_wait_ready>
  hd44780_outcmd(HD44780_DISPCTL(0, 0, 0));
     fd0:	60 e0       	ldi	r22, 0x00	; 0
     fd2:	88 e0       	ldi	r24, 0x08	; 8
     fd4:	0e 94 8d 07 	call	0xf1a	; 0xf1a <hd44780_outbyte>
  hd44780_wait_ready();//_delay_ms(15);//
     fd8:	0e 94 ac 07 	call	0xf58	; 0xf58 <hd44780_wait_ready>
     fdc:	08 95       	ret

00000fde <lcd_init>:
  return 0;
}
// clear LCD
void cls_lcd (void)
{	hd44780_wait_ready();
	hd44780_outcmd(HD44780_CLR);
     fde:	0e 94 b2 07 	call	0xf64	; 0xf64 <hd44780_init>
     fe2:	60 e0       	ldi	r22, 0x00	; 0
     fe4:	81 e0       	ldi	r24, 0x01	; 1
     fe6:	0e 94 8d 07 	call	0xf1a	; 0xf1a <hd44780_outbyte>
     fea:	0e 94 ac 07 	call	0xf58	; 0xf58 <hd44780_wait_ready>
     fee:	60 e0       	ldi	r22, 0x00	; 0
     ff0:	86 e0       	ldi	r24, 0x06	; 6
     ff2:	0e 94 8d 07 	call	0xf1a	; 0xf1a <hd44780_outbyte>
     ff6:	0e 94 ac 07 	call	0xf58	; 0xf58 <hd44780_wait_ready>
     ffa:	60 e0       	ldi	r22, 0x00	; 0
     ffc:	8e e0       	ldi	r24, 0x0E	; 14
     ffe:	0e 94 8d 07 	call	0xf1a	; 0xf1a <hd44780_outbyte>
    1002:	0e 94 ac 07 	call	0xf58	; 0xf58 <hd44780_wait_ready>
    1006:	08 95       	ret

00001008 <lcd_putchar>:
    1008:	cf 93       	push	r28
    100a:	c8 2f       	mov	r28, r24
    100c:	80 91 ca 02 	lds	r24, 0x02CA	; 0x8002ca <nl_seen.1960>
    1010:	88 23       	and	r24, r24
    1012:	b1 f0       	breq	.+44     	; 0x1040 <lcd_putchar+0x38>
    1014:	ca 30       	cpi	r28, 0x0A	; 10
    1016:	a1 f0       	breq	.+40     	; 0x1040 <lcd_putchar+0x38>
    1018:	0e 94 ac 07 	call	0xf58	; 0xf58 <hd44780_wait_ready>
    101c:	60 e0       	ldi	r22, 0x00	; 0
    101e:	81 e0       	ldi	r24, 0x01	; 1
    1020:	0e 94 8d 07 	call	0xf1a	; 0xf1a <hd44780_outbyte>
    1024:	0e 94 ac 07 	call	0xf58	; 0xf58 <hd44780_wait_ready>
    1028:	60 e0       	ldi	r22, 0x00	; 0
    102a:	82 e0       	ldi	r24, 0x02	; 2
    102c:	0e 94 8d 07 	call	0xf1a	; 0xf1a <hd44780_outbyte>
    1030:	0e 94 ac 07 	call	0xf58	; 0xf58 <hd44780_wait_ready>
    1034:	60 e0       	ldi	r22, 0x00	; 0
    1036:	80 e8       	ldi	r24, 0x80	; 128
    1038:	0e 94 8d 07 	call	0xf1a	; 0xf1a <hd44780_outbyte>
    103c:	10 92 ca 02 	sts	0x02CA, r1	; 0x8002ca <nl_seen.1960>
    1040:	ca 30       	cpi	r28, 0x0A	; 10
    1042:	21 f4       	brne	.+8      	; 0x104c <lcd_putchar+0x44>
    1044:	81 e0       	ldi	r24, 0x01	; 1
    1046:	80 93 ca 02 	sts	0x02CA, r24	; 0x8002ca <nl_seen.1960>
    104a:	06 c0       	rjmp	.+12     	; 0x1058 <lcd_putchar+0x50>
    104c:	0e 94 ac 07 	call	0xf58	; 0xf58 <hd44780_wait_ready>
    1050:	61 e0       	ldi	r22, 0x01	; 1
    1052:	8c 2f       	mov	r24, r28
    1054:	0e 94 8d 07 	call	0xf1a	; 0xf1a <hd44780_outbyte>
    1058:	80 e0       	ldi	r24, 0x00	; 0
    105a:	90 e0       	ldi	r25, 0x00	; 0
    105c:	cf 91       	pop	r28
    105e:	08 95       	ret

00001060 <position>:
	
}

void position ( unsigned char c , unsigned char l)
{	unsigned char p;
    1060:	cf 93       	push	r28
    1062:	df 93       	push	r29
    1064:	d8 2f       	mov	r29, r24
    1066:	c6 2f       	mov	r28, r22
	hd44780_wait_ready();
    1068:	0e 94 ac 07 	call	0xf58	; 0xf58 <hd44780_wait_ready>
	if ( (l <2)  &&  (c<16 ))
    106c:	c2 30       	cpi	r28, 0x02	; 2
    106e:	58 f4       	brcc	.+22     	; 0x1086 <position+0x26>
    1070:	d0 31       	cpi	r29, 0x10	; 16
    1072:	48 f4       	brcc	.+18     	; 0x1086 <position+0x26>
		{p = c + 0x40 * l;
    1074:	8d 2f       	mov	r24, r29
    1076:	90 e4       	ldi	r25, 0x40	; 64
    1078:	c9 9f       	mul	r28, r25
    107a:	80 0d       	add	r24, r0
    107c:	11 24       	eor	r1, r1
		  hd44780_outcmd(HD44780_DDADDR(p));
    107e:	60 e0       	ldi	r22, 0x00	; 0
    1080:	80 68       	ori	r24, 0x80	; 128
    1082:	0e 94 8d 07 	call	0xf1a	; 0xf1a <hd44780_outbyte>
		}
	
}
    1086:	df 91       	pop	r29
    1088:	cf 91       	pop	r28
    108a:	08 95       	ret

0000108c <initPort>:
	
	return (0);
}

void initPort(void){
	DDRB=0x0F;
    108c:	8f e0       	ldi	r24, 0x0F	; 15
    108e:	87 bb       	out	0x17, r24	; 23
	PORTB=0x0F;
    1090:	88 bb       	out	0x18, r24	; 24
	DDRD=0;
    1092:	11 ba       	out	0x11, r1	; 17
    1094:	08 95       	ret

00001096 <init_SPI_CNA>:
}

void init_SPI_CNA(void)
{
	DDRB |= 0xB0 ;
    1096:	87 b3       	in	r24, 0x17	; 23
    1098:	80 6b       	ori	r24, 0xB0	; 176
    109a:	87 bb       	out	0x17, r24	; 23
	SPCR = 0b01010001 ; // MSB first, maitre, f/8, front montant
    109c:	81 e5       	ldi	r24, 0x51	; 81
    109e:	8d b9       	out	0x0d, r24	; 13
	SPSR = 1 << SPI2X ;
    10a0:	81 e0       	ldi	r24, 0x01	; 1
    10a2:	8e b9       	out	0x0e, r24	; 14
    10a4:	08 95       	ret

000010a6 <SPI_transmit>:
}

void SPI_transmit(char cData)
{
	SPDR = cData;                    //depose l'octet
    10a6:	8f b9       	out	0x0f, r24	; 15
	
	while(!(SPSR & (1 << SPIF)));        //attend la fin de transmission
    10a8:	77 9b       	sbis	0x0e, 7	; 14
    10aa:	fe cf       	rjmp	.-4      	; 0x10a8 <SPI_transmit+0x2>
}
    10ac:	08 95       	ret

000010ae <SPI_CNA>:

void SPI_CNA(unsigned int val, unsigned char voie, unsigned char mult)
{
    10ae:	cf 93       	push	r28
    10b0:	c8 2f       	mov	r28, r24
	unsigned char oct1;
	unsigned char oct2;
	
	PORTB &= ~(1<<PB4);//Csna a 0
    10b2:	88 b3       	in	r24, 0x18	; 24
    10b4:	8f 7e       	andi	r24, 0xEF	; 239
    10b6:	88 bb       	out	0x18, r24	; 24
	
	oct1 = ((val >> 8) & 0x0F) | 0x10 ;    //appliquer masque
    10b8:	9f 70       	andi	r25, 0x0F	; 15
    10ba:	89 2f       	mov	r24, r25
    10bc:	80 61       	ori	r24, 0x10	; 16
	
	if (voie==1) oct1 |= 0x80 ;    //dfinir la voie
    10be:	61 30       	cpi	r22, 0x01	; 1
    10c0:	11 f4       	brne	.+4      	; 0x10c6 <SPI_CNA+0x18>
    10c2:	89 2f       	mov	r24, r25
    10c4:	80 69       	ori	r24, 0x90	; 144
	if (mult==1) oct1 | 0x20 ;
	
	SPI_transmit(oct1) ;
    10c6:	0e 94 53 08 	call	0x10a6	; 0x10a6 <SPI_transmit>

	oct2 = (unsigned char) val ;

	SPI_transmit(oct2) ;
    10ca:	8c 2f       	mov	r24, r28
    10cc:	0e 94 53 08 	call	0x10a6	; 0x10a6 <SPI_transmit>

	PORTB |= (1<<PB4) ; //Csna a 1
    10d0:	88 b3       	in	r24, 0x18	; 24
    10d2:	80 61       	ori	r24, 0x10	; 16
    10d4:	88 bb       	out	0x18, r24	; 24

}
    10d6:	cf 91       	pop	r28
    10d8:	08 95       	ret

000010da <__vector_4>:

ISR (TIMER2_COMP_vect)
{
    10da:	1f 92       	push	r1
    10dc:	0f 92       	push	r0
    10de:	0f b6       	in	r0, 0x3f	; 63
    10e0:	0f 92       	push	r0
    10e2:	11 24       	eor	r1, r1
    10e4:	2f 93       	push	r18
    10e6:	3f 93       	push	r19
    10e8:	4f 93       	push	r20
    10ea:	5f 93       	push	r21
    10ec:	6f 93       	push	r22
    10ee:	7f 93       	push	r23
    10f0:	8f 93       	push	r24
    10f2:	9f 93       	push	r25
    10f4:	af 93       	push	r26
    10f6:	bf 93       	push	r27
    10f8:	ef 93       	push	r30
    10fa:	ff 93       	push	r31
	unsigned int valeurs = (data[i] * ampli);
    10fc:	e0 91 f3 04 	lds	r30, 0x04F3	; 0x8004f3 <i>
    1100:	f0 e0       	ldi	r31, 0x00	; 0
    1102:	ec 50       	subi	r30, 0x0C	; 12
    1104:	fb 4f       	sbci	r31, 0xFB	; 251
    1106:	90 81       	ld	r25, Z
    1108:	80 91 f2 04 	lds	r24, 0x04F2	; 0x8004f2 <ampli>

	SPI_CNA(valeurs, 0, 0);
    110c:	40 e0       	ldi	r20, 0x00	; 0
    110e:	60 e0       	ldi	r22, 0x00	; 0
    1110:	98 9f       	mul	r25, r24
    1112:	c0 01       	movw	r24, r0
    1114:	11 24       	eor	r1, r1
    1116:	0e 94 57 08 	call	0x10ae	; 0x10ae <SPI_CNA>
	
	i++;
    111a:	80 91 f3 04 	lds	r24, 0x04F3	; 0x8004f3 <i>
    111e:	8f 5f       	subi	r24, 0xFF	; 255
    1120:	80 93 f3 04 	sts	0x04F3, r24	; 0x8004f3 <i>
	i %= 64;
    1124:	80 91 f3 04 	lds	r24, 0x04F3	; 0x8004f3 <i>
    1128:	8f 73       	andi	r24, 0x3F	; 63
    112a:	80 93 f3 04 	sts	0x04F3, r24	; 0x8004f3 <i>
	
	PORTB ^= (1<<PB3);
    112e:	98 b3       	in	r25, 0x18	; 24
    1130:	88 e0       	ldi	r24, 0x08	; 8
    1132:	89 27       	eor	r24, r25
    1134:	88 bb       	out	0x18, r24	; 24
	
}
    1136:	ff 91       	pop	r31
    1138:	ef 91       	pop	r30
    113a:	bf 91       	pop	r27
    113c:	af 91       	pop	r26
    113e:	9f 91       	pop	r25
    1140:	8f 91       	pop	r24
    1142:	7f 91       	pop	r23
    1144:	6f 91       	pop	r22
    1146:	5f 91       	pop	r21
    1148:	4f 91       	pop	r20
    114a:	3f 91       	pop	r19
    114c:	2f 91       	pop	r18
    114e:	0f 90       	pop	r0
    1150:	0f be       	out	0x3f, r0	; 63
    1152:	0f 90       	pop	r0
    1154:	1f 90       	pop	r1
    1156:	18 95       	reti

00001158 <InitTimer2>:

void InitTimer2(void) // FQ = 8MHz
{    
	TCCR2 = 0x02 | (1<<WGM21); //mode CTC et f/8
    1158:	8a e0       	ldi	r24, 0x0A	; 10
    115a:	85 bd       	out	0x25, r24	; 37
	OCR2 = 249;    //T= 8*(1+249)/(8*10^6)=250s
    115c:	89 ef       	ldi	r24, 0xF9	; 249
    115e:	83 bd       	out	0x23, r24	; 35
	TIMSK = 1<<OCIE2;    //autorise linterruption
    1160:	80 e8       	ldi	r24, 0x80	; 128
    1162:	89 bf       	out	0x39, r24	; 57
    1164:	08 95       	ret

00001166 <clav>:
}

unsigned char clav(void)
{
    1166:	cf 93       	push	r28
    1168:	df 93       	push	r29
    116a:	cd b7       	in	r28, 0x3d	; 61
    116c:	de b7       	in	r29, 0x3e	; 62
    116e:	60 97       	sbiw	r28, 0x10	; 16
    1170:	0f b6       	in	r0, 0x3f	; 63
    1172:	f8 94       	cli
    1174:	de bf       	out	0x3e, r29	; 62
    1176:	0f be       	out	0x3f, r0	; 63
    1178:	cd bf       	out	0x3d, r28	; 61
	unsigned char t = 0;
	unsigned char tabtouche[16] = {'1','2','3','F','4','5','6','E','7','8','9','D','A','0','C', 'D'}; 
    117a:	80 e1       	ldi	r24, 0x10	; 16
    117c:	ea e7       	ldi	r30, 0x7A	; 122
    117e:	f0 e0       	ldi	r31, 0x00	; 0
    1180:	de 01       	movw	r26, r28
    1182:	11 96       	adiw	r26, 0x01	; 1
    1184:	01 90       	ld	r0, Z+
    1186:	0d 92       	st	X+, r0
    1188:	8a 95       	dec	r24
    118a:	e1 f7       	brne	.-8      	; 0x1184 <clav+0x1e>
	
	t = (PINA >> 1) & 0x0F;
    118c:	89 b3       	in	r24, 0x19	; 25
    118e:	86 95       	lsr	r24
    1190:	8f 70       	andi	r24, 0x0F	; 15
	
	return tabtouche[t];
    1192:	e1 e0       	ldi	r30, 0x01	; 1
    1194:	f0 e0       	ldi	r31, 0x00	; 0
    1196:	ec 0f       	add	r30, r28
    1198:	fd 1f       	adc	r31, r29
    119a:	e8 0f       	add	r30, r24
    119c:	f1 1d       	adc	r31, r1
    119e:	80 81       	ld	r24, Z
    11a0:	60 96       	adiw	r28, 0x10	; 16
    11a2:	0f b6       	in	r0, 0x3f	; 63
    11a4:	f8 94       	cli
    11a6:	de bf       	out	0x3e, r29	; 62
    11a8:	0f be       	out	0x3f, r0	; 63
    11aa:	cd bf       	out	0x3d, r28	; 61
    11ac:	df 91       	pop	r29
    11ae:	cf 91       	pop	r28
    11b0:	08 95       	ret

000011b2 <main>:
volatile unsigned char ampli;


int main (void)
{
	stdout = &lcd_str;
    11b2:	80 e6       	ldi	r24, 0x60	; 96
    11b4:	90 e0       	ldi	r25, 0x00	; 0
    11b6:	90 93 8f 05 	sts	0x058F, r25	; 0x80058f <__iob+0x3>
    11ba:	80 93 8e 05 	sts	0x058E, r24	; 0x80058e <__iob+0x2>
	
	File * myfile;
	
	initPort();    // configurer et teindre les Leds L4  L1, sur PB3..PB0 (voir TP1)
    11be:	0e 94 46 08 	call	0x108c	; 0x108c <initPort>
	
	if (!(PIND & (1<<PD2))){    // si carte SD prsente
    11c2:	82 99       	sbic	0x10, 2	; 16
    11c4:	1d c0       	rjmp	.+58     	; 0x1200 <main+0x4e>
		if ( InitFat16())    // si le systme peut tre initialis
    11c6:	0e 94 72 00 	call	0xe4	; 0xe4 <InitFat16>
    11ca:	88 23       	and	r24, r24
    11cc:	c9 f0       	breq	.+50     	; 0x1200 <main+0x4e>
		{
			myfile = fopen_("fileTP30.bin", 'r'); // on ouvre "fileTP30.bin" en lecture, et on l'affecte au pointeur de myfile
    11ce:	62 e7       	ldi	r22, 0x72	; 114
    11d0:	8a e8       	ldi	r24, 0x8A	; 138
    11d2:	92 e0       	ldi	r25, 0x02	; 2
    11d4:	0e 94 0c 07 	call	0xe18	; 0xe18 <fopen_>
    11d8:	ec 01       	movw	r28, r24
			
			fread_(data, 64, 1, myfile); // on lit le flux de my file et on met les donnes dans le tableau
    11da:	7c 01       	movw	r14, r24
    11dc:	01 e0       	ldi	r16, 0x01	; 1
    11de:	10 e0       	ldi	r17, 0x00	; 0
    11e0:	20 e0       	ldi	r18, 0x00	; 0
    11e2:	30 e0       	ldi	r19, 0x00	; 0
    11e4:	40 e4       	ldi	r20, 0x40	; 64
    11e6:	50 e0       	ldi	r21, 0x00	; 0
    11e8:	60 e0       	ldi	r22, 0x00	; 0
    11ea:	70 e0       	ldi	r23, 0x00	; 0
    11ec:	84 ef       	ldi	r24, 0xF4	; 244
    11ee:	94 e0       	ldi	r25, 0x04	; 4
    11f0:	0e 94 6e 03 	call	0x6dc	; 0x6dc <fread_>
			
			fclose_(myfile); // on ferme le flux myfile
    11f4:	ce 01       	movw	r24, r28
    11f6:	0e 94 46 07 	call	0xe8c	; 0xe8c <fclose_>
			
			PORTB |= (1 << PB0) ;    // allumer Led L1
    11fa:	88 b3       	in	r24, 0x18	; 24
    11fc:	81 60       	ori	r24, 0x01	; 1
    11fe:	88 bb       	out	0x18, r24	; 24
		}
	}
	
	cli();
    1200:	f8 94       	cli
	
	init_SPI_CNA();
    1202:	0e 94 4b 08 	call	0x1096	; 0x1096 <init_SPI_CNA>
	InitTimer2();
    1206:	0e 94 ac 08 	call	0x1158	; 0x1158 <InitTimer2>
	lcd_init();
    120a:	0e 94 ef 07 	call	0xfde	; 0xfde <lcd_init>
	
	sei();
    120e:	78 94       	sei
	
	while (1) {
		
		if(PIND & (1 << PD3))    //detection de lappuis dune touche
    1210:	83 9b       	sbis	0x10, 3	; 16
    1212:	20 c0       	rjmp	.+64     	; 0x1254 <main+0xa2>
		{
			while(PIND&(1<<PD3)); //attente touche relache
    1214:	83 99       	sbic	0x10, 3	; 16
    1216:	fe cf       	rjmp	.-4      	; 0x1214 <main+0x62>
			
			if(clav() == '1')
    1218:	0e 94 b3 08 	call	0x1166	; 0x1166 <clav>
    121c:	81 33       	cpi	r24, 0x31	; 49
    121e:	59 f4       	brne	.+22     	; 0x1236 <main+0x84>
			{
				cli();
    1220:	f8 94       	cli
			
				if(ampli != 16) ampli += 1;
    1222:	80 91 f2 04 	lds	r24, 0x04F2	; 0x8004f2 <ampli>
    1226:	80 31       	cpi	r24, 0x10	; 16
    1228:	29 f0       	breq	.+10     	; 0x1234 <main+0x82>
    122a:	80 91 f2 04 	lds	r24, 0x04F2	; 0x8004f2 <ampli>
    122e:	8f 5f       	subi	r24, 0xFF	; 255
    1230:	80 93 f2 04 	sts	0x04F2, r24	; 0x8004f2 <ampli>
		
				sei();
    1234:	78 94       	sei
				
			}
			if(clav() == 'F')
    1236:	0e 94 b3 08 	call	0x1166	; 0x1166 <clav>
    123a:	86 34       	cpi	r24, 0x46	; 70
    123c:	59 f4       	brne	.+22     	; 0x1254 <main+0xa2>
			{
				cli();
    123e:	f8 94       	cli
		
				if(ampli != 0) ampli -= 1 ;
    1240:	80 91 f2 04 	lds	r24, 0x04F2	; 0x8004f2 <ampli>
    1244:	88 23       	and	r24, r24
    1246:	29 f0       	breq	.+10     	; 0x1252 <main+0xa0>
    1248:	80 91 f2 04 	lds	r24, 0x04F2	; 0x8004f2 <ampli>
    124c:	81 50       	subi	r24, 0x01	; 1
    124e:	80 93 f2 04 	sts	0x04F2, r24	; 0x8004f2 <ampli>
		
				sei();
    1252:	78 94       	sei
			}
			
		}
		
		position(0, 0);
    1254:	60 e0       	ldi	r22, 0x00	; 0
    1256:	80 e0       	ldi	r24, 0x00	; 0
    1258:	0e 94 30 08 	call	0x1060	; 0x1060 <position>
		printf("Amplification: ");
    125c:	87 e9       	ldi	r24, 0x97	; 151
    125e:	92 e0       	ldi	r25, 0x02	; 2
    1260:	9f 93       	push	r25
    1262:	8f 93       	push	r24
    1264:	0e 94 e9 0c 	call	0x19d2	; 0x19d2 <printf>
		
		position(0, 1);
    1268:	61 e0       	ldi	r22, 0x01	; 1
    126a:	80 e0       	ldi	r24, 0x00	; 0
    126c:	0e 94 30 08 	call	0x1060	; 0x1060 <position>
		printf("%02d",ampli);
    1270:	80 91 f2 04 	lds	r24, 0x04F2	; 0x8004f2 <ampli>
    1274:	1f 92       	push	r1
    1276:	8f 93       	push	r24
    1278:	87 ea       	ldi	r24, 0xA7	; 167
    127a:	92 e0       	ldi	r25, 0x02	; 2
    127c:	9f 93       	push	r25
    127e:	8f 93       	push	r24
    1280:	0e 94 e9 0c 	call	0x19d2	; 0x19d2 <printf>
	}
    1284:	0f 90       	pop	r0
    1286:	0f 90       	pop	r0
    1288:	0f 90       	pop	r0
    128a:	0f 90       	pop	r0
    128c:	0f 90       	pop	r0
    128e:	0f 90       	pop	r0
    1290:	bf cf       	rjmp	.-130    	; 0x1210 <main+0x5e>

00001292 <CRC7>:
//
// Returnvalue: the function returns nothing
//________________________________________________________________________________________________________________________________________

void SDC_PrintCID(u8 * pCID)
{
    1292:	cf 92       	push	r12
    1294:	df 92       	push	r13
    1296:	ef 92       	push	r14
    1298:	ff 92       	push	r15
    129a:	0f 93       	push	r16
    129c:	1f 93       	push	r17
    129e:	dc 01       	movw	r26, r24
    12a0:	6a 01       	movw	r12, r20
    12a2:	7b 01       	movw	r14, r22
    12a4:	90 e0       	ldi	r25, 0x00	; 0
    12a6:	60 e0       	ldi	r22, 0x00	; 0
    12a8:	11 c0       	rjmp	.+34     	; 0x12cc <CRC7+0x3a>
    12aa:	fd 01       	movw	r30, r26
    12ac:	e6 0f       	add	r30, r22
    12ae:	f1 1d       	adc	r31, r1
    12b0:	30 81       	ld	r19, Z
    12b2:	20 e0       	ldi	r18, 0x00	; 0
    12b4:	08 c0       	rjmp	.+16     	; 0x12c6 <CRC7+0x34>
    12b6:	99 0f       	add	r25, r25
    12b8:	53 2f       	mov	r21, r19
    12ba:	59 27       	eor	r21, r25
    12bc:	14 f4       	brge	.+4      	; 0x12c2 <CRC7+0x30>
    12be:	59 e0       	ldi	r21, 0x09	; 9
    12c0:	95 27       	eor	r25, r21
    12c2:	33 0f       	add	r19, r19
    12c4:	2f 5f       	subi	r18, 0xFF	; 255
    12c6:	28 30       	cpi	r18, 0x08	; 8
    12c8:	b0 f3       	brcs	.-20     	; 0x12b6 <CRC7+0x24>
    12ca:	6f 5f       	subi	r22, 0xFF	; 255
    12cc:	06 2f       	mov	r16, r22
    12ce:	10 e0       	ldi	r17, 0x00	; 0
    12d0:	20 e0       	ldi	r18, 0x00	; 0
    12d2:	30 e0       	ldi	r19, 0x00	; 0
    12d4:	0c 15       	cp	r16, r12
    12d6:	1d 05       	cpc	r17, r13
    12d8:	2e 05       	cpc	r18, r14
    12da:	3f 05       	cpc	r19, r15
    12dc:	30 f3       	brcs	.-52     	; 0x12aa <CRC7+0x18>
    12de:	89 2f       	mov	r24, r25
    12e0:	90 e0       	ldi	r25, 0x00	; 0
    12e2:	88 0f       	add	r24, r24
    12e4:	99 1f       	adc	r25, r25
    12e6:	81 60       	ori	r24, 0x01	; 1
    12e8:	1f 91       	pop	r17
    12ea:	0f 91       	pop	r16
    12ec:	ff 90       	pop	r15
    12ee:	ef 90       	pop	r14
    12f0:	df 90       	pop	r13
    12f2:	cf 90       	pop	r12
    12f4:	08 95       	ret

000012f6 <SDC_WaitForBusy>:
    12f6:	cf 93       	push	r28
    12f8:	df 93       	push	r29
    12fa:	0e 94 86 0c 	call	0x190c	; 0x190c <SSC_ClearRxFifo>
    12fe:	0e 94 a9 0c 	call	0x1952	; 0x1952 <SSC_Enable>
    1302:	c0 e0       	ldi	r28, 0x00	; 0
    1304:	d0 e0       	ldi	r29, 0x00	; 0
    1306:	0e 94 87 0c 	call	0x190e	; 0x190e <SSC_GetChar>
    130a:	9e 01       	movw	r18, r28
    130c:	2f 5f       	subi	r18, 0xFF	; 255
    130e:	3f 4f       	sbci	r19, 0xFF	; 255
    1310:	c5 3f       	cpi	r28, 0xF5	; 245
    1312:	d1 40       	sbci	r29, 0x01	; 1
    1314:	18 f4       	brcc	.+6      	; 0x131c <SDC_WaitForBusy+0x26>
    1316:	e9 01       	movw	r28, r18
    1318:	8f 3f       	cpi	r24, 0xFF	; 255
    131a:	a9 f7       	brne	.-22     	; 0x1306 <SDC_WaitForBusy+0x10>
    131c:	df 91       	pop	r29
    131e:	cf 91       	pop	r28
    1320:	08 95       	ret

00001322 <SDC_SendCMDR1>:
    1322:	df 92       	push	r13
    1324:	ef 92       	push	r14
    1326:	ff 92       	push	r15
    1328:	0f 93       	push	r16
    132a:	1f 93       	push	r17
    132c:	cf 93       	push	r28
    132e:	df 93       	push	r29
    1330:	00 d0       	rcall	.+0      	; 0x1332 <SDC_SendCMDR1+0x10>
    1332:	00 d0       	rcall	.+0      	; 0x1334 <SDC_SendCMDR1+0x12>
    1334:	00 d0       	rcall	.+0      	; 0x1336 <SDC_SendCMDR1+0x14>
    1336:	cd b7       	in	r28, 0x3d	; 61
    1338:	de b7       	in	r29, 0x3e	; 62
    133a:	18 2f       	mov	r17, r24
    133c:	04 2f       	mov	r16, r20
    133e:	f5 2e       	mov	r15, r21
    1340:	e6 2e       	mov	r14, r22
    1342:	d7 2e       	mov	r13, r23
    1344:	0e 94 86 0c 	call	0x190c	; 0x190c <SSC_ClearRxFifo>
    1348:	0e 94 a9 0c 	call	0x1952	; 0x1952 <SSC_Enable>
    134c:	0e 94 7b 09 	call	0x12f6	; 0x12f6 <SDC_WaitForBusy>
    1350:	0e 94 86 0c 	call	0x190c	; 0x190c <SSC_ClearRxFifo>
    1354:	0e 94 87 0c 	call	0x190e	; 0x190e <SSC_GetChar>
    1358:	10 64       	ori	r17, 0x40	; 64
    135a:	19 83       	std	Y+1, r17	; 0x01
    135c:	da 82       	std	Y+2, r13	; 0x02
    135e:	eb 82       	std	Y+3, r14	; 0x03
    1360:	fc 82       	std	Y+4, r15	; 0x04
    1362:	0d 83       	std	Y+5, r16	; 0x05
    1364:	45 e0       	ldi	r20, 0x05	; 5
    1366:	50 e0       	ldi	r21, 0x00	; 0
    1368:	60 e0       	ldi	r22, 0x00	; 0
    136a:	70 e0       	ldi	r23, 0x00	; 0
    136c:	ce 01       	movw	r24, r28
    136e:	01 96       	adiw	r24, 0x01	; 1
    1370:	0e 94 49 09 	call	0x1292	; 0x1292 <CRC7>
    1374:	8e 83       	std	Y+6, r24	; 0x06
    1376:	00 e0       	ldi	r16, 0x00	; 0
    1378:	10 e0       	ldi	r17, 0x00	; 0
    137a:	0b c0       	rjmp	.+22     	; 0x1392 <SDC_SendCMDR1+0x70>
    137c:	e1 e0       	ldi	r30, 0x01	; 1
    137e:	f0 e0       	ldi	r31, 0x00	; 0
    1380:	ec 0f       	add	r30, r28
    1382:	fd 1f       	adc	r31, r29
    1384:	e0 0f       	add	r30, r16
    1386:	f1 1f       	adc	r31, r17
    1388:	80 81       	ld	r24, Z
    138a:	0e 94 8d 0c 	call	0x191a	; 0x191a <SSC_PutChar>
    138e:	0f 5f       	subi	r16, 0xFF	; 255
    1390:	1f 4f       	sbci	r17, 0xFF	; 255
    1392:	06 30       	cpi	r16, 0x06	; 6
    1394:	11 05       	cpc	r17, r1
    1396:	90 f3       	brcs	.-28     	; 0x137c <SDC_SendCMDR1+0x5a>
    1398:	0e 94 86 0c 	call	0x190c	; 0x190c <SSC_ClearRxFifo>
    139c:	00 e0       	ldi	r16, 0x00	; 0
    139e:	10 e0       	ldi	r17, 0x00	; 0
    13a0:	0e 94 87 0c 	call	0x190e	; 0x190e <SSC_GetChar>
    13a4:	98 01       	movw	r18, r16
    13a6:	2f 5f       	subi	r18, 0xFF	; 255
    13a8:	3f 4f       	sbci	r19, 0xFF	; 255
    13aa:	05 3f       	cpi	r16, 0xF5	; 245
    13ac:	11 40       	sbci	r17, 0x01	; 1
    13ae:	18 f4       	brcc	.+6      	; 0x13b6 <SDC_SendCMDR1+0x94>
    13b0:	89 01       	movw	r16, r18
    13b2:	8f 3f       	cpi	r24, 0xFF	; 255
    13b4:	a9 f3       	breq	.-22     	; 0x13a0 <SDC_SendCMDR1+0x7e>
    13b6:	26 96       	adiw	r28, 0x06	; 6
    13b8:	0f b6       	in	r0, 0x3f	; 63
    13ba:	f8 94       	cli
    13bc:	de bf       	out	0x3e, r29	; 62
    13be:	0f be       	out	0x3f, r0	; 63
    13c0:	cd bf       	out	0x3d, r28	; 61
    13c2:	df 91       	pop	r29
    13c4:	cf 91       	pop	r28
    13c6:	1f 91       	pop	r17
    13c8:	0f 91       	pop	r16
    13ca:	ff 90       	pop	r15
    13cc:	ef 90       	pop	r14
    13ce:	df 90       	pop	r13
    13d0:	08 95       	ret

000013d2 <SDC_SendACMDR1>:
    13d2:	cf 92       	push	r12
    13d4:	df 92       	push	r13
    13d6:	ef 92       	push	r14
    13d8:	ff 92       	push	r15
    13da:	cf 93       	push	r28
    13dc:	c8 2f       	mov	r28, r24
    13de:	6a 01       	movw	r12, r20
    13e0:	7b 01       	movw	r14, r22
    13e2:	40 e0       	ldi	r20, 0x00	; 0
    13e4:	50 e0       	ldi	r21, 0x00	; 0
    13e6:	ba 01       	movw	r22, r20
    13e8:	87 e3       	ldi	r24, 0x37	; 55
    13ea:	0e 94 91 09 	call	0x1322	; 0x1322 <SDC_SendCMDR1>
    13ee:	88 23       	and	r24, r24
    13f0:	2c f0       	brlt	.+10     	; 0x13fc <SDC_SendACMDR1+0x2a>
    13f2:	b7 01       	movw	r22, r14
    13f4:	a6 01       	movw	r20, r12
    13f6:	8c 2f       	mov	r24, r28
    13f8:	0e 94 91 09 	call	0x1322	; 0x1322 <SDC_SendCMDR1>
    13fc:	cf 91       	pop	r28
    13fe:	ff 90       	pop	r15
    1400:	ef 90       	pop	r14
    1402:	df 90       	pop	r13
    1404:	cf 90       	pop	r12
    1406:	08 95       	ret

00001408 <SDC_GetData>:
    1408:	8f 92       	push	r8
    140a:	9f 92       	push	r9
    140c:	af 92       	push	r10
    140e:	bf 92       	push	r11
    1410:	cf 92       	push	r12
    1412:	df 92       	push	r13
    1414:	ef 92       	push	r14
    1416:	ff 92       	push	r15
    1418:	0f 93       	push	r16
    141a:	1f 93       	push	r17
    141c:	cf 93       	push	r28
    141e:	df 93       	push	r29
    1420:	69 01       	movw	r12, r18
    1422:	47 01       	movw	r8, r14
    1424:	58 01       	movw	r10, r16
    1426:	0e 94 91 09 	call	0x1322	; 0x1322 <SDC_SendCMDR1>
    142a:	81 11       	cpse	r24, r1
    142c:	22 c0       	rjmp	.+68     	; 0x1472 <SDC_GetData+0x6a>
    142e:	0e 94 86 0c 	call	0x190c	; 0x190c <SSC_ClearRxFifo>
    1432:	0e 94 87 0c 	call	0x190e	; 0x190e <SSC_GetChar>
    1436:	98 2f       	mov	r25, r24
    1438:	90 7f       	andi	r25, 0xF0	; 240
    143a:	e9 f0       	breq	.+58     	; 0x1476 <SDC_GetData+0x6e>
    143c:	8e 3f       	cpi	r24, 0xFE	; 254
    143e:	c9 f7       	brne	.-14     	; 0x1432 <SDC_GetData+0x2a>
    1440:	c0 e0       	ldi	r28, 0x00	; 0
    1442:	d0 e0       	ldi	r29, 0x00	; 0
    1444:	08 c0       	rjmp	.+16     	; 0x1456 <SDC_GetData+0x4e>
    1446:	86 01       	movw	r16, r12
    1448:	0c 0f       	add	r16, r28
    144a:	1d 1f       	adc	r17, r29
    144c:	0e 94 87 0c 	call	0x190e	; 0x190e <SSC_GetChar>
    1450:	f8 01       	movw	r30, r16
    1452:	80 83       	st	Z, r24
    1454:	21 96       	adiw	r28, 0x01	; 1
    1456:	ce 01       	movw	r24, r28
    1458:	a0 e0       	ldi	r26, 0x00	; 0
    145a:	b0 e0       	ldi	r27, 0x00	; 0
    145c:	88 15       	cp	r24, r8
    145e:	99 05       	cpc	r25, r9
    1460:	aa 05       	cpc	r26, r10
    1462:	bb 05       	cpc	r27, r11
    1464:	80 f3       	brcs	.-32     	; 0x1446 <SDC_GetData+0x3e>
    1466:	0e 94 87 0c 	call	0x190e	; 0x190e <SSC_GetChar>
    146a:	0e 94 87 0c 	call	0x190e	; 0x190e <SSC_GetChar>
    146e:	80 e0       	ldi	r24, 0x00	; 0
    1470:	03 c0       	rjmp	.+6      	; 0x1478 <SDC_GetData+0x70>
    1472:	84 e0       	ldi	r24, 0x04	; 4
    1474:	01 c0       	rjmp	.+2      	; 0x1478 <SDC_GetData+0x70>
    1476:	8a e0       	ldi	r24, 0x0A	; 10
    1478:	df 91       	pop	r29
    147a:	cf 91       	pop	r28
    147c:	1f 91       	pop	r17
    147e:	0f 91       	pop	r16
    1480:	ff 90       	pop	r15
    1482:	ef 90       	pop	r14
    1484:	df 90       	pop	r13
    1486:	cf 90       	pop	r12
    1488:	bf 90       	pop	r11
    148a:	af 90       	pop	r10
    148c:	9f 90       	pop	r9
    148e:	8f 90       	pop	r8
    1490:	08 95       	ret

00001492 <SDC_GetCID>:
//
// Returnvalue: the function returns error state
//________________________________________________________________________________________________________________________________________

SD_Result_t SDC_GetCID(u8 * pCID) 
{
    1492:	ef 92       	push	r14
    1494:	ff 92       	push	r15
    1496:	0f 93       	push	r16
    1498:	1f 93       	push	r17
	return SDC_GetData(CMD_SEND_CID, 0UL, pCID, 16);
    149a:	10 e1       	ldi	r17, 0x10	; 16
    149c:	e1 2e       	mov	r14, r17
    149e:	f1 2c       	mov	r15, r1
    14a0:	00 e0       	ldi	r16, 0x00	; 0
    14a2:	10 e0       	ldi	r17, 0x00	; 0
    14a4:	9c 01       	movw	r18, r24
    14a6:	40 e0       	ldi	r20, 0x00	; 0
    14a8:	50 e0       	ldi	r21, 0x00	; 0
    14aa:	ba 01       	movw	r22, r20
    14ac:	8a e0       	ldi	r24, 0x0A	; 10
    14ae:	0e 94 04 0a 	call	0x1408	; 0x1408 <SDC_GetData>
}
    14b2:	1f 91       	pop	r17
    14b4:	0f 91       	pop	r16
    14b6:	ff 90       	pop	r15
    14b8:	ef 90       	pop	r14
    14ba:	08 95       	ret

000014bc <SDC_GetCSD>:
//
// Returnvalue: the function returns error state
//________________________________________________________________________________________________________________________________________

SD_Result_t SDC_GetCSD(u8 * pCSD) 
{
    14bc:	ef 92       	push	r14
    14be:	ff 92       	push	r15
    14c0:	0f 93       	push	r16
    14c2:	1f 93       	push	r17
	return SDC_GetData(CMD_SEND_CSD, 0UL, pCSD, 16);
    14c4:	10 e1       	ldi	r17, 0x10	; 16
    14c6:	e1 2e       	mov	r14, r17
    14c8:	f1 2c       	mov	r15, r1
    14ca:	00 e0       	ldi	r16, 0x00	; 0
    14cc:	10 e0       	ldi	r17, 0x00	; 0
    14ce:	9c 01       	movw	r18, r24
    14d0:	40 e0       	ldi	r20, 0x00	; 0
    14d2:	50 e0       	ldi	r21, 0x00	; 0
    14d4:	ba 01       	movw	r22, r20
    14d6:	89 e0       	ldi	r24, 0x09	; 9
    14d8:	0e 94 04 0a 	call	0x1408	; 0x1408 <SDC_GetData>
}
    14dc:	1f 91       	pop	r17
    14de:	0f 91       	pop	r16
    14e0:	ff 90       	pop	r15
    14e2:	ef 90       	pop	r14
    14e4:	08 95       	ret

000014e6 <SDC_Init>:
//
// Returnvalue: the function returns 0 if the initialisation was successfull otherwise the function returns an errorcode.
//________________________________________________________________________________________________________________________________________

SD_Result_t SDC_Init(void)
{
    14e6:	cf 92       	push	r12
    14e8:	df 92       	push	r13
    14ea:	ef 92       	push	r14
    14ec:	ff 92       	push	r15
    14ee:	1f 93       	push	r17
    14f0:	cf 93       	push	r28
    14f2:	df 93       	push	r29
    14f4:	00 d0       	rcall	.+0      	; 0x14f6 <SDC_Init+0x10>
    14f6:	00 d0       	rcall	.+0      	; 0x14f8 <SDC_Init+0x12>
    14f8:	00 d0       	rcall	.+0      	; 0x14fa <SDC_Init+0x14>
    14fa:	cd b7       	in	r28, 0x3d	; 61
    14fc:	de b7       	in	r29, 0x3e	; 62
	u8 rsp[6]; // SD-SPI response buffer
	SD_Result_t result = SD_ERROR_UNKNOWN;
		
	if(1)//CARD_DETECT) 										// init only if the SD-Switch is indicating a card in the slot
	{
    	SSC_Init();
    14fe:	0e 94 95 0c 	call	0x192a	; 0x192a <SSC_Init>
		SDCardInfo.Valid = 0;
    1502:	10 92 34 05 	sts	0x0534, r1	; 0x800534 <SDCardInfo>
		/* The host shall supply power to the card so that the voltage is reached to Vdd_min within 250ms and
		start to supply at least 74 SD clocks to the SD card with keeping cmd line to high. In case of SPI
		mode, CS shall be held to high during 74 clock cycles. */
		SSC_Disable(); // set SD_CS high
    1506:	0e 94 91 0c 	call	0x1922	; 0x1922 <SSC_Disable>
		SSC_ClearRxFifo();	// clear the rx fifo
    150a:	0e 94 86 0c 	call	0x190c	; 0x190c <SSC_ClearRxFifo>
	
		for (Timeout = 0; Timeout < 15; Timeout++) 	// 15*8 = 120 cycles
    150e:	c1 2c       	mov	r12, r1
    1510:	d1 2c       	mov	r13, r1
    1512:	76 01       	movw	r14, r12
    1514:	08 c0       	rjmp	.+16     	; 0x1526 <SDC_Init+0x40>
		{
			SSC_PutChar(0xFF);
    1516:	8f ef       	ldi	r24, 0xFF	; 255
    1518:	0e 94 8d 0c 	call	0x191a	; 0x191a <SSC_PutChar>
		start to supply at least 74 SD clocks to the SD card with keeping cmd line to high. In case of SPI
		mode, CS shall be held to high during 74 clock cycles. */
		SSC_Disable(); // set SD_CS high
		SSC_ClearRxFifo();	// clear the rx fifo
	
		for (Timeout = 0; Timeout < 15; Timeout++) 	// 15*8 = 120 cycles
    151c:	2f ef       	ldi	r18, 0xFF	; 255
    151e:	c2 1a       	sub	r12, r18
    1520:	d2 0a       	sbc	r13, r18
    1522:	e2 0a       	sbc	r14, r18
    1524:	f2 0a       	sbc	r15, r18
    1526:	8f e0       	ldi	r24, 0x0F	; 15
    1528:	c8 16       	cp	r12, r24
    152a:	d1 04       	cpc	r13, r1
    152c:	e1 04       	cpc	r14, r1
    152e:	f1 04       	cpc	r15, r1
    1530:	90 f3       	brcs	.-28     	; 0x1516 <SDC_Init+0x30>
    1532:	0e c0       	rjmp	.+28     	; 0x1550 <SDC_Init+0x6a>
		}
	
		// switch to idle state
		while(!(SDC_SendCMDR1(CMD_GO_IDLE_STATE, 0UL) & R1_IDLE_STATE))						
		{
			if (Timeout++ > 20)
    1534:	d7 01       	movw	r26, r14
    1536:	c6 01       	movw	r24, r12
    1538:	01 96       	adiw	r24, 0x01	; 1
    153a:	a1 1d       	adc	r26, r1
    153c:	b1 1d       	adc	r27, r1
    153e:	25 e1       	ldi	r18, 0x15	; 21
    1540:	c2 16       	cp	r12, r18
    1542:	d1 04       	cpc	r13, r1
    1544:	e1 04       	cpc	r14, r1
    1546:	f1 04       	cpc	r15, r1
    1548:	08 f0       	brcs	.+2      	; 0x154c <SDC_Init+0x66>
    154a:	19 c1       	rjmp	.+562    	; 0x177e <SDC_Init+0x298>
    154c:	6c 01       	movw	r12, r24
    154e:	7d 01       	movw	r14, r26
		{
			SSC_PutChar(0xFF);
		}
	
		// switch to idle state
		while(!(SDC_SendCMDR1(CMD_GO_IDLE_STATE, 0UL) & R1_IDLE_STATE))						
    1550:	40 e0       	ldi	r20, 0x00	; 0
    1552:	50 e0       	ldi	r21, 0x00	; 0
    1554:	ba 01       	movw	r22, r20
    1556:	80 e0       	ldi	r24, 0x00	; 0
    1558:	0e 94 91 09 	call	0x1322	; 0x1322 <SDC_SendCMDR1>
    155c:	80 ff       	sbrs	r24, 0
    155e:	ea cf       	rjmp	.-44     	; 0x1534 <SDC_Init+0x4e>
			{
				result = SD_ERROR_RESET;
				goto end; 										
			}
		}
		rsp[0] = SDC_SendCMDR1(CMD_SEND_IF_COND, 0x000001AA);
    1560:	4a ea       	ldi	r20, 0xAA	; 170
    1562:	51 e0       	ldi	r21, 0x01	; 1
    1564:	60 e0       	ldi	r22, 0x00	; 0
    1566:	70 e0       	ldi	r23, 0x00	; 0
    1568:	88 e0       	ldi	r24, 0x08	; 8
    156a:	0e 94 91 09 	call	0x1322	; 0x1322 <SDC_SendCMDR1>
		// answer to cmd58 is an R7 response (R1+ 4Byte IFCond)
		if(rsp[0] & R1_BAD_RESPONSE)
    156e:	88 23       	and	r24, r24
    1570:	0c f4       	brge	.+2      	; 0x1574 <SDC_Init+0x8e>
    1572:	07 c1       	rjmp	.+526    	; 0x1782 <SDC_Init+0x29c>
		{
			result = SD_ERROR_BAD_RESPONSE;
			goto end;
		} 
		if(rsp[0] & R1_ILLEGAL_CMD)
    1574:	82 ff       	sbrs	r24, 2
    1576:	04 c0       	rjmp	.+8      	; 0x1580 <SDC_Init+0x9a>
		{
			//Ver1.X SD Memory Card or not a SD Memory Card
			SDCardInfo.Version = VER_1X;			
    1578:	81 e0       	ldi	r24, 0x01	; 1
    157a:	80 93 35 05 	sts	0x0535, r24	; 0x800535 <SDCardInfo+0x1>
    157e:	25 c0       	rjmp	.+74     	; 0x15ca <SDC_Init+0xe4>
		}
		else
		{
		   // Ver2.00 or later SD Memory Card
		   // reading the remaining bytes of the R7 response
		   SDCardInfo.Version = VER_20;
    1580:	82 e0       	ldi	r24, 0x02	; 2
    1582:	80 93 35 05 	sts	0x0535, r24	; 0x800535 <SDCardInfo+0x1>
		   for(Timeout = 1; Timeout < 5; Timeout++)
    1586:	c1 2c       	mov	r12, r1
    1588:	d1 2c       	mov	r13, r1
    158a:	76 01       	movw	r14, r12
    158c:	c3 94       	inc	r12
    158e:	0e c0       	rjmp	.+28     	; 0x15ac <SDC_Init+0xc6>
		   {
				rsp[Timeout] = SSC_GetChar();
    1590:	0e 94 87 0c 	call	0x190e	; 0x190e <SSC_GetChar>
    1594:	e1 e0       	ldi	r30, 0x01	; 1
    1596:	f0 e0       	ldi	r31, 0x00	; 0
    1598:	ec 0f       	add	r30, r28
    159a:	fd 1f       	adc	r31, r29
    159c:	ec 0d       	add	r30, r12
    159e:	fd 1d       	adc	r31, r13
    15a0:	80 83       	st	Z, r24
		else
		{
		   // Ver2.00 or later SD Memory Card
		   // reading the remaining bytes of the R7 response
		   SDCardInfo.Version = VER_20;
		   for(Timeout = 1; Timeout < 5; Timeout++)
    15a2:	8f ef       	ldi	r24, 0xFF	; 255
    15a4:	c8 1a       	sub	r12, r24
    15a6:	d8 0a       	sbc	r13, r24
    15a8:	e8 0a       	sbc	r14, r24
    15aa:	f8 0a       	sbc	r15, r24
    15ac:	25 e0       	ldi	r18, 0x05	; 5
    15ae:	c2 16       	cp	r12, r18
    15b0:	d1 04       	cpc	r13, r1
    15b2:	e1 04       	cpc	r14, r1
    15b4:	f1 04       	cpc	r15, r1
    15b6:	60 f3       	brcs	.-40     	; 0x1590 <SDC_Init+0xaa>
		   {
				rsp[Timeout] = SSC_GetChar();
		   }
		   //check pattern
		   if(rsp[4]!= 0xAA)
    15b8:	8d 81       	ldd	r24, Y+5	; 0x05
    15ba:	8a 3a       	cpi	r24, 0xAA	; 170
    15bc:	09 f0       	breq	.+2      	; 0x15c0 <SDC_Init+0xda>
    15be:	e3 c0       	rjmp	.+454    	; 0x1786 <SDC_Init+0x2a0>
		   {
				result = SD_ERROR_BAD_RESPONSE;
				goto end;
		   }
		   if ( (rsp[3] & 0x0F)!= 0x01 ) // voltage range is not 2.7-3.6V
    15c0:	8c 81       	ldd	r24, Y+4	; 0x04
    15c2:	8f 70       	andi	r24, 0x0F	; 15
    15c4:	81 30       	cpi	r24, 0x01	; 1
    15c6:	09 f0       	breq	.+2      	; 0x15ca <SDC_Init+0xe4>
    15c8:	e0 c0       	rjmp	.+448    	; 0x178a <SDC_Init+0x2a4>
				result = SD_ERROR_BAD_VOLTAGE_RANGE;
				goto end;		
		   } 
		}
	
		rsp[0] = SDC_SendCMDR1(CMD_READ_OCR, 0UL);
    15ca:	40 e0       	ldi	r20, 0x00	; 0
    15cc:	50 e0       	ldi	r21, 0x00	; 0
    15ce:	ba 01       	movw	r22, r20
    15d0:	8a e3       	ldi	r24, 0x3A	; 58
    15d2:	0e 94 91 09 	call	0x1322	; 0x1322 <SDC_SendCMDR1>
		// answer to cmd58 is an R3 response (R1 + 4Byte OCR)
		if(rsp[0] & R1_BAD_RESPONSE)
    15d6:	88 23       	and	r24, r24
    15d8:	0c f4       	brge	.+2      	; 0x15dc <SDC_Init+0xf6>
    15da:	d9 c0       	rjmp	.+434    	; 0x178e <SDC_Init+0x2a8>
		{
			result = SD_ERROR_BAD_RESPONSE;
			goto end;
		}
		if(rsp[0] & R1_ILLEGAL_CMD)
    15dc:	82 fd       	sbrc	r24, 2
    15de:	d9 c0       	rjmp	.+434    	; 0x1792 <SDC_Init+0x2ac>
    15e0:	c1 2c       	mov	r12, r1
    15e2:	d1 2c       	mov	r13, r1
    15e4:	76 01       	movw	r14, r12
    15e6:	c3 94       	inc	r12
    15e8:	0e c0       	rjmp	.+28     	; 0x1606 <SDC_Init+0x120>
			goto end;
		}
		// read 4 bytes of OCR register
		for(Timeout = 1; Timeout < 5; Timeout++)
		{
			rsp[Timeout] = SSC_GetChar();
    15ea:	0e 94 87 0c 	call	0x190e	; 0x190e <SSC_GetChar>
    15ee:	e1 e0       	ldi	r30, 0x01	; 1
    15f0:	f0 e0       	ldi	r31, 0x00	; 0
    15f2:	ec 0f       	add	r30, r28
    15f4:	fd 1f       	adc	r31, r29
    15f6:	ec 0d       	add	r30, r12
    15f8:	fd 1d       	adc	r31, r13
    15fa:	80 83       	st	Z, r24
		{
			result = SD_ERROR_NO_SDCARD;
			goto end;
		}
		// read 4 bytes of OCR register
		for(Timeout = 1; Timeout < 5; Timeout++)
    15fc:	8f ef       	ldi	r24, 0xFF	; 255
    15fe:	c8 1a       	sub	r12, r24
    1600:	d8 0a       	sbc	r13, r24
    1602:	e8 0a       	sbc	r14, r24
    1604:	f8 0a       	sbc	r15, r24
    1606:	25 e0       	ldi	r18, 0x05	; 5
    1608:	c2 16       	cp	r12, r18
    160a:	d1 04       	cpc	r13, r1
    160c:	e1 04       	cpc	r14, r1
    160e:	f1 04       	cpc	r15, r1
    1610:	60 f3       	brcs	.-40     	; 0x15ea <SDC_Init+0x104>
		{
			rsp[Timeout] = SSC_GetChar();
		}
		//	NavicCtrl uses 3.3 V,  therefore check for bit 20 & 21 
		if((rsp[2] & 0x30) != 0x30)
    1612:	8b 81       	ldd	r24, Y+3	; 0x03
    1614:	80 73       	andi	r24, 0x30	; 48
    1616:	80 33       	cpi	r24, 0x30	; 48
    1618:	09 f0       	breq	.+2      	; 0x161c <SDC_Init+0x136>
    161a:	bd c0       	rjmp	.+378    	; 0x1796 <SDC_Init+0x2b0>
		
		// Initialize the sd-card sending continously ACMD_SEND_OP_COND (only supported by SD cards)
//		Timeout =  SetDelay(2000); // set timeout to 2000 ms (large cards tend to longer) 
		do
		{
			rsp[0] = SDC_SendACMDR1(ACMD_SEND_OP_COND, 0UL);
    161c:	40 e0       	ldi	r20, 0x00	; 0
    161e:	50 e0       	ldi	r21, 0x00	; 0
    1620:	ba 01       	movw	r22, r20
    1622:	89 e2       	ldi	r24, 0x29	; 41
    1624:	0e 94 e9 09 	call	0x13d2	; 0x13d2 <SDC_SendACMDR1>
			if(rsp[0] & R1_BAD_RESPONSE)
    1628:	88 23       	and	r24, r24
    162a:	0c f4       	brge	.+2      	; 0x162e <SDC_Init+0x148>
    162c:	b6 c0       	rjmp	.+364    	; 0x179a <SDC_Init+0x2b4>
/*			if(CheckDelay(Timeout))
			{
				result = SD_ERROR_INITIALIZE;
				goto end;
			}*/
		} while(rsp[0] & R1_IDLE_STATE); // loop until idle state
    162e:	80 fd       	sbrc	r24, 0
    1630:	f5 cf       	rjmp	.-22     	; 0x161c <SDC_Init+0x136>
		
		if(rsp[0] != R1_NO_ERR)
    1632:	81 11       	cpse	r24, r1
    1634:	b4 c0       	rjmp	.+360    	; 0x179e <SDC_Init+0x2b8>
		{
		 	result = SD_ERROR_INITIALIZE;
			goto end; 	
		}
		/* set block size to 512 bytes */
    	if(SDC_SendCMDR1(CMD_SET_BLOCKLEN, 512UL) != R1_NO_ERR)
    1636:	40 e0       	ldi	r20, 0x00	; 0
    1638:	52 e0       	ldi	r21, 0x02	; 2
    163a:	60 e0       	ldi	r22, 0x00	; 0
    163c:	70 e0       	ldi	r23, 0x00	; 0
    163e:	80 e1       	ldi	r24, 0x10	; 16
    1640:	0e 94 91 09 	call	0x1322	; 0x1322 <SDC_SendCMDR1>
    1644:	81 11       	cpse	r24, r1
    1646:	ad c0       	rjmp	.+346    	; 0x17a2 <SDC_Init+0x2bc>


//		SSC_Init_High();	// init ssc in highspeed mode.

		// read CID register
		result = SDC_GetCID((u8 *)&SDCardInfo.CID);
    1648:	8a e3       	ldi	r24, 0x3A	; 58
    164a:	95 e0       	ldi	r25, 0x05	; 5
    164c:	0e 94 49 0a 	call	0x1492	; 0x1492 <SDC_GetCID>
    1650:	18 2f       	mov	r17, r24
		if(result != SD_SUCCESS)
    1652:	81 11       	cpse	r24, r1
    1654:	a7 c0       	rjmp	.+334    	; 0x17a4 <SDC_Init+0x2be>
		{
			goto end;
		}
	
		// read CSD register
		result = SDC_GetCSD((u8 *)&SDCardInfo.CSD);
    1656:	8a e4       	ldi	r24, 0x4A	; 74
    1658:	95 e0       	ldi	r25, 0x05	; 5
    165a:	0e 94 5e 0a 	call	0x14bc	; 0x14bc <SDC_GetCSD>
    165e:	18 2f       	mov	r17, r24
		if(result != SD_SUCCESS)
    1660:	81 11       	cpse	r24, r1
    1662:	a0 c0       	rjmp	.+320    	; 0x17a4 <SDC_Init+0x2be>
		}
	
		u8 c_size_mult, read_bl_len;
		u32 c_size;
	
		switch(SDCardInfo.CSD[0]>>6) // check CSD Version
    1664:	80 91 4a 05 	lds	r24, 0x054A	; 0x80054a <SDCardInfo+0x16>
    1668:	82 95       	swap	r24
    166a:	86 95       	lsr	r24
    166c:	86 95       	lsr	r24
    166e:	83 70       	andi	r24, 0x03	; 3
    1670:	21 f0       	breq	.+8      	; 0x167a <SDC_Init+0x194>
    1672:	81 30       	cpi	r24, 0x01	; 1
    1674:	09 f4       	brne	.+2      	; 0x1678 <SDC_Init+0x192>
    1676:	4d c0       	rjmp	.+154    	; 0x1712 <SDC_Init+0x22c>
    1678:	76 c0       	rjmp	.+236    	; 0x1766 <SDC_Init+0x280>
			C_SIZE      is 12 bits [73:62] in CSD register
			C_SIZE_MULT is  3 bits [49:47] in CSD register
			READ_BL_LEN is  4 bits [83:80] in CSD register
			*/
	
			read_bl_len = (SDCardInfo.CSD[5] & 0x0F); 		//CSD[05] -> [87:80]
    167a:	e4 e3       	ldi	r30, 0x34	; 52
    167c:	f5 e0       	ldi	r31, 0x05	; 5
    167e:	23 8d       	ldd	r18, Z+27	; 0x1b
    1680:	2f 70       	andi	r18, 0x0F	; 15
			c_size = ((u32)(SDCardInfo.CSD[6] & 0x03))<<10; //CSD[06] -> [79:72]
    1682:	84 8d       	ldd	r24, Z+28	; 0x1c
    1684:	83 70       	andi	r24, 0x03	; 3
    1686:	90 e0       	ldi	r25, 0x00	; 0
    1688:	a0 e0       	ldi	r26, 0x00	; 0
    168a:	b0 e0       	ldi	r27, 0x00	; 0
    168c:	ac 01       	movw	r20, r24
    168e:	bd 01       	movw	r22, r26
    1690:	03 2e       	mov	r0, r19
    1692:	3a e0       	ldi	r19, 0x0A	; 10
    1694:	44 0f       	add	r20, r20
    1696:	55 1f       	adc	r21, r21
    1698:	66 1f       	adc	r22, r22
    169a:	77 1f       	adc	r23, r23
    169c:	3a 95       	dec	r19
    169e:	d1 f7       	brne	.-12     	; 0x1694 <SDC_Init+0x1ae>
    16a0:	30 2d       	mov	r19, r0
			c_size |= ((u32)SDCardInfo.CSD[7])<<2;			//CSD[07] -> [71:64]
    16a2:	95 8d       	ldd	r25, Z+29	; 0x1d
    16a4:	89 2f       	mov	r24, r25
    16a6:	90 e0       	ldi	r25, 0x00	; 0
    16a8:	a0 e0       	ldi	r26, 0x00	; 0
    16aa:	b0 e0       	ldi	r27, 0x00	; 0
    16ac:	88 0f       	add	r24, r24
    16ae:	99 1f       	adc	r25, r25
    16b0:	aa 1f       	adc	r26, r26
    16b2:	bb 1f       	adc	r27, r27
    16b4:	88 0f       	add	r24, r24
    16b6:	99 1f       	adc	r25, r25
    16b8:	aa 1f       	adc	r26, r26
    16ba:	bb 1f       	adc	r27, r27
    16bc:	84 2b       	or	r24, r20
    16be:	95 2b       	or	r25, r21
    16c0:	a6 2b       	or	r26, r22
    16c2:	b7 2b       	or	r27, r23
			c_size |= (u32)(SDCardInfo.CSD[8]>>6);			//CSD[08] -> [63:56]
    16c4:	36 8d       	ldd	r19, Z+30	; 0x1e
    16c6:	32 95       	swap	r19
    16c8:	36 95       	lsr	r19
    16ca:	36 95       	lsr	r19
    16cc:	33 70       	andi	r19, 0x03	; 3
    16ce:	83 2b       	or	r24, r19
			c_size_mult = (SDCardInfo.CSD[9] & 0x03)<<1;  	//CSD[09] -> [55:48]
    16d0:	37 8d       	ldd	r19, Z+31	; 0x1f
    16d2:	33 70       	andi	r19, 0x03	; 3
    16d4:	33 0f       	add	r19, r19
			c_size_mult |=(SDCardInfo.CSD[10] & 0x80)>>7;	//CSD[10] -> [47:40]
    16d6:	40 a1       	ldd	r20, Z+32	; 0x20
    16d8:	44 1f       	adc	r20, r20
    16da:	44 27       	eor	r20, r20
    16dc:	44 1f       	adc	r20, r20
    16de:	43 2b       	or	r20, r19
			SDCardInfo.Capacity = (u32)(c_size+1)*(1L<<(c_size_mult+2))*(1L<<read_bl_len);
    16e0:	01 96       	adiw	r24, 0x01	; 1
    16e2:	a1 1d       	adc	r26, r1
    16e4:	b1 1d       	adc	r27, r1
    16e6:	50 e0       	ldi	r21, 0x00	; 0
    16e8:	4e 5f       	subi	r20, 0xFE	; 254
    16ea:	5f 4f       	sbci	r21, 0xFF	; 255
    16ec:	04 c0       	rjmp	.+8      	; 0x16f6 <SDC_Init+0x210>
    16ee:	88 0f       	add	r24, r24
    16f0:	99 1f       	adc	r25, r25
    16f2:	aa 1f       	adc	r26, r26
    16f4:	bb 1f       	adc	r27, r27
    16f6:	4a 95       	dec	r20
    16f8:	d2 f7       	brpl	.-12     	; 0x16ee <SDC_Init+0x208>
    16fa:	04 c0       	rjmp	.+8      	; 0x1704 <SDC_Init+0x21e>
    16fc:	88 0f       	add	r24, r24
    16fe:	99 1f       	adc	r25, r25
    1700:	aa 1f       	adc	r26, r26
    1702:	bb 1f       	adc	r27, r27
    1704:	2a 95       	dec	r18
    1706:	d2 f7       	brpl	.-12     	; 0x16fc <SDC_Init+0x216>
    1708:	82 83       	std	Z+2, r24	; 0x02
    170a:	93 83       	std	Z+3, r25	; 0x03
    170c:	a4 83       	std	Z+4, r26	; 0x04
    170e:	b5 83       	std	Z+5, r27	; 0x05
			break;
    1710:	32 c0       	rjmp	.+100    	; 0x1776 <SDC_Init+0x290>
			/*
			memory capacity = (C_SIZE+1) * 512K byte
			C_SIZE is 22 bits [69:48] in CSR register 
			*/
	
			c_size = ((u32)(SDCardInfo.CSD[7] & 0x3F))<<16;	//CSD[07] -> [71:64]
    1712:	e4 e3       	ldi	r30, 0x34	; 52
    1714:	f5 e0       	ldi	r31, 0x05	; 5
    1716:	85 8d       	ldd	r24, Z+29	; 0x1d
    1718:	8f 73       	andi	r24, 0x3F	; 63
    171a:	90 e0       	ldi	r25, 0x00	; 0
    171c:	a0 e0       	ldi	r26, 0x00	; 0
    171e:	b0 e0       	ldi	r27, 0x00	; 0
    1720:	bc 01       	movw	r22, r24
    1722:	55 27       	eor	r21, r21
    1724:	44 27       	eor	r20, r20
			c_size |= ((u32)SDCardInfo.CSD[8])<<8;			//CSD[08] -> [63:56]
    1726:	96 8d       	ldd	r25, Z+30	; 0x1e
    1728:	89 2f       	mov	r24, r25
    172a:	90 e0       	ldi	r25, 0x00	; 0
    172c:	a0 e0       	ldi	r26, 0x00	; 0
    172e:	b0 e0       	ldi	r27, 0x00	; 0
    1730:	ba 2f       	mov	r27, r26
    1732:	a9 2f       	mov	r26, r25
    1734:	98 2f       	mov	r25, r24
    1736:	88 27       	eor	r24, r24
    1738:	84 2b       	or	r24, r20
    173a:	95 2b       	or	r25, r21
    173c:	a6 2b       	or	r26, r22
    173e:	b7 2b       	or	r27, r23
			c_size |= (u32)SDCardInfo.CSD[9];  				//CSD[09] -> [55:48];
    1740:	27 8d       	ldd	r18, Z+31	; 0x1f
    1742:	82 2b       	or	r24, r18
		 	SDCardInfo.Capacity = (c_size + 1)* 512L * 1024L;
    1744:	01 96       	adiw	r24, 0x01	; 1
    1746:	a1 1d       	adc	r26, r1
    1748:	b1 1d       	adc	r27, r1
    174a:	07 2e       	mov	r0, r23
    174c:	73 e1       	ldi	r23, 0x13	; 19
    174e:	88 0f       	add	r24, r24
    1750:	99 1f       	adc	r25, r25
    1752:	aa 1f       	adc	r26, r26
    1754:	bb 1f       	adc	r27, r27
    1756:	7a 95       	dec	r23
    1758:	d1 f7       	brne	.-12     	; 0x174e <SDC_Init+0x268>
    175a:	70 2d       	mov	r23, r0
    175c:	82 83       	std	Z+2, r24	; 0x02
    175e:	93 83       	std	Z+3, r25	; 0x03
    1760:	a4 83       	std	Z+4, r26	; 0x04
    1762:	b5 83       	std	Z+5, r27	; 0x05
			break;
    1764:	08 c0       	rjmp	.+16     	; 0x1776 <SDC_Init+0x290>
	
		default: //unknown CSD Version
			SDCardInfo.Capacity = 0;
    1766:	10 92 36 05 	sts	0x0536, r1	; 0x800536 <SDCardInfo+0x2>
    176a:	10 92 37 05 	sts	0x0537, r1	; 0x800537 <SDCardInfo+0x3>
    176e:	10 92 38 05 	sts	0x0538, r1	; 0x800538 <SDCardInfo+0x4>
    1772:	10 92 39 05 	sts	0x0539, r1	; 0x800539 <SDCardInfo+0x5>
//		u16 mb_size = (u16)(SDCardInfo.Capacity/(1024L*1024L));	
//		s8 text[40];
//		sprintf(text,"\r\nsize: %d",mb_size);
//		PutString(text);
//		SDC_PrintCID((u8 *)&SDCardInfo.CID);
		SDCardInfo.Valid = 1;
    1776:	81 e0       	ldi	r24, 0x01	; 1
    1778:	80 93 34 05 	sts	0x0534, r24	; 0x800534 <SDCardInfo>
    177c:	13 c0       	rjmp	.+38     	; 0x17a4 <SDC_Init+0x2be>
		// switch to idle state
		while(!(SDC_SendCMDR1(CMD_GO_IDLE_STATE, 0UL) & R1_IDLE_STATE))						
		{
			if (Timeout++ > 20)
			{
				result = SD_ERROR_RESET;
    177e:	12 e0       	ldi	r17, 0x02	; 2
    1780:	11 c0       	rjmp	.+34     	; 0x17a4 <SDC_Init+0x2be>
		}
		rsp[0] = SDC_SendCMDR1(CMD_SEND_IF_COND, 0x000001AA);
		// answer to cmd58 is an R7 response (R1+ 4Byte IFCond)
		if(rsp[0] & R1_BAD_RESPONSE)
		{
			result = SD_ERROR_BAD_RESPONSE;
    1782:	14 e0       	ldi	r17, 0x04	; 4
    1784:	0f c0       	rjmp	.+30     	; 0x17a4 <SDC_Init+0x2be>
				rsp[Timeout] = SSC_GetChar();
		   }
		   //check pattern
		   if(rsp[4]!= 0xAA)
		   {
				result = SD_ERROR_BAD_RESPONSE;
    1786:	14 e0       	ldi	r17, 0x04	; 4
    1788:	0d c0       	rjmp	.+26     	; 0x17a4 <SDC_Init+0x2be>
				goto end;
		   }
		   if ( (rsp[3] & 0x0F)!= 0x01 ) // voltage range is not 2.7-3.6V
		   {
				result = SD_ERROR_BAD_VOLTAGE_RANGE;
    178a:	15 e0       	ldi	r17, 0x05	; 5
    178c:	0b c0       	rjmp	.+22     	; 0x17a4 <SDC_Init+0x2be>
	
		rsp[0] = SDC_SendCMDR1(CMD_READ_OCR, 0UL);
		// answer to cmd58 is an R3 response (R1 + 4Byte OCR)
		if(rsp[0] & R1_BAD_RESPONSE)
		{
			result = SD_ERROR_BAD_RESPONSE;
    178e:	14 e0       	ldi	r17, 0x04	; 4
    1790:	09 c0       	rjmp	.+18     	; 0x17a4 <SDC_Init+0x2be>
			goto end;
		}
		if(rsp[0] & R1_ILLEGAL_CMD)
		{
			result = SD_ERROR_NO_SDCARD;
    1792:	16 e0       	ldi	r17, 0x06	; 6
    1794:	07 c0       	rjmp	.+14     	; 0x17a4 <SDC_Init+0x2be>
		}
		//	NavicCtrl uses 3.3 V,  therefore check for bit 20 & 21 
		if((rsp[2] & 0x30) != 0x30)
		{
		 	// supply voltage is not supported by sd-card
			result = SD_ERROR_BAD_VOLTAGE_RANGE;
    1796:	15 e0       	ldi	r17, 0x05	; 5
    1798:	05 c0       	rjmp	.+10     	; 0x17a4 <SDC_Init+0x2be>
		do
		{
			rsp[0] = SDC_SendACMDR1(ACMD_SEND_OP_COND, 0UL);
			if(rsp[0] & R1_BAD_RESPONSE)
			{
				result = SD_ERROR_BAD_RESPONSE;
    179a:	14 e0       	ldi	r17, 0x04	; 4
    179c:	03 c0       	rjmp	.+6      	; 0x17a4 <SDC_Init+0x2be>
			}*/
		} while(rsp[0] & R1_IDLE_STATE); // loop until idle state
		
		if(rsp[0] != R1_NO_ERR)
		{
		 	result = SD_ERROR_INITIALIZE;
    179e:	13 e0       	ldi	r17, 0x03	; 3
    17a0:	01 c0       	rjmp	.+2      	; 0x17a4 <SDC_Init+0x2be>
			goto end; 	
		}
		/* set block size to 512 bytes */
    	if(SDC_SendCMDR1(CMD_SET_BLOCKLEN, 512UL) != R1_NO_ERR)
    	{
		 	result = SD_ERROR_SET_BLOCKLEN;
    17a2:	1b e0       	ldi	r17, 0x0B	; 11
//		SDC_PrintCID((u8 *)&SDCardInfo.CID);
		SDCardInfo.Valid = 1;
			
		// jump point for error	condition before
		end:
		SSC_Disable();
    17a4:	0e 94 91 0c 	call	0x1922	; 0x1922 <SSC_Disable>
		SDCardInfo.Valid = 0;
		result = SD_ERROR_NOCARD;
	}

	return(result);
}
    17a8:	81 2f       	mov	r24, r17
    17aa:	26 96       	adiw	r28, 0x06	; 6
    17ac:	0f b6       	in	r0, 0x3f	; 63
    17ae:	f8 94       	cli
    17b0:	de bf       	out	0x3e, r29	; 62
    17b2:	0f be       	out	0x3f, r0	; 63
    17b4:	cd bf       	out	0x3d, r28	; 61
    17b6:	df 91       	pop	r29
    17b8:	cf 91       	pop	r28
    17ba:	1f 91       	pop	r17
    17bc:	ff 90       	pop	r15
    17be:	ef 90       	pop	r14
    17c0:	df 90       	pop	r13
    17c2:	cf 90       	pop	r12
    17c4:	08 95       	ret

000017c6 <SDC_PutSector>:
//
// Returnvalue: SD_Result_t
//________________________________________________________________________________________________________________________________________

SD_Result_t SDC_PutSector(u32 addr, const u8 *Buffer)
{
    17c6:	ef 92       	push	r14
    17c8:	ff 92       	push	r15
    17ca:	0f 93       	push	r16
    17cc:	1f 93       	push	r17
    17ce:	cf 93       	push	r28
    17d0:	df 93       	push	r29
    17d2:	8a 01       	movw	r16, r20
	u16 timeout = 0;
	u16 a, Crc16;
	//u32 Timeout = 0;
	SD_Result_t result = SD_ERROR_UNKNOWN;

	addr = addr << 9; // convert sectoradress to byteadress
    17d4:	ab 01       	movw	r20, r22
    17d6:	bc 01       	movw	r22, r24
    17d8:	03 2e       	mov	r0, r19
    17da:	39 e0       	ldi	r19, 0x09	; 9
    17dc:	44 0f       	add	r20, r20
    17de:	55 1f       	adc	r21, r21
    17e0:	66 1f       	adc	r22, r22
    17e2:	77 1f       	adc	r23, r23
    17e4:	3a 95       	dec	r19
    17e6:	d1 f7       	brne	.-12     	; 0x17dc <SDC_PutSector+0x16>
    17e8:	30 2d       	mov	r19, r0
	rsp = SDC_SendCMDR1(CMD_WRITE_SINGLE_BLOCK, addr);
    17ea:	88 e1       	ldi	r24, 0x18	; 24
    17ec:	0e 94 91 09 	call	0x1322	; 0x1322 <SDC_SendCMDR1>
	if (rsp != R1_NO_ERR)
    17f0:	81 11       	cpse	r24, r1
    17f2:	61 c0       	rjmp	.+194    	; 0x18b6 <SDC_PutSector+0xf0>
	{
		result = SD_ERROR_BAD_RESPONSE;
		goto end;
	}
	SSC_ClearRxFifo();		
    17f4:	0e 94 86 0c 	call	0x190c	; 0x190c <SSC_ClearRxFifo>
	for (a=0;a<20;a++)					// at least one byte
    17f8:	c0 e0       	ldi	r28, 0x00	; 0
    17fa:	d0 e0       	ldi	r29, 0x00	; 0
    17fc:	03 c0       	rjmp	.+6      	; 0x1804 <SDC_PutSector+0x3e>
	{
		SSC_GetChar();
    17fe:	0e 94 87 0c 	call	0x190e	; 0x190e <SSC_GetChar>
	{
		result = SD_ERROR_BAD_RESPONSE;
		goto end;
	}
	SSC_ClearRxFifo();		
	for (a=0;a<20;a++)					// at least one byte
    1802:	21 96       	adiw	r28, 0x01	; 1
    1804:	c4 31       	cpi	r28, 0x14	; 20
    1806:	d1 05       	cpc	r29, r1
    1808:	d0 f3       	brcs	.-12     	; 0x17fe <SDC_PutSector+0x38>
	{
		SSC_GetChar();
	}
	Crc16 = CRC16(Buffer, 512);         // calc checksum for data block
    180a:	40 e0       	ldi	r20, 0x00	; 0
    180c:	52 e0       	ldi	r21, 0x02	; 2
    180e:	60 e0       	ldi	r22, 0x00	; 0
    1810:	70 e0       	ldi	r23, 0x00	; 0
    1812:	c8 01       	movw	r24, r16
    1814:	0e 94 49 00 	call	0x92	; 0x92 <CRC16>
    1818:	f8 2e       	mov	r15, r24
    181a:	e9 2e       	mov	r14, r25
	SSC_PutChar(DATA_START_TOKEN);		// send data start of header to the SSC	
    181c:	8e ef       	ldi	r24, 0xFE	; 254
    181e:	0e 94 8d 0c 	call	0x191a	; 0x191a <SSC_PutChar>
	
	for (a=0;a<512;a++)					// transmit one sector (normaly 512bytes) of data to the sdcard.
    1822:	c0 e0       	ldi	r28, 0x00	; 0
    1824:	d0 e0       	ldi	r29, 0x00	; 0
    1826:	07 c0       	rjmp	.+14     	; 0x1836 <SDC_PutSector+0x70>
	{
		SSC_PutChar(Buffer[a]);
    1828:	f8 01       	movw	r30, r16
    182a:	ec 0f       	add	r30, r28
    182c:	fd 1f       	adc	r31, r29
    182e:	80 81       	ld	r24, Z
    1830:	0e 94 8d 0c 	call	0x191a	; 0x191a <SSC_PutChar>
		SSC_GetChar();
	}
	Crc16 = CRC16(Buffer, 512);         // calc checksum for data block
	SSC_PutChar(DATA_START_TOKEN);		// send data start of header to the SSC	
	
	for (a=0;a<512;a++)					// transmit one sector (normaly 512bytes) of data to the sdcard.
    1834:	21 96       	adiw	r28, 0x01	; 1
    1836:	c1 15       	cp	r28, r1
    1838:	82 e0       	ldi	r24, 0x02	; 2
    183a:	d8 07       	cpc	r29, r24
    183c:	a8 f3       	brcs	.-22     	; 0x1828 <SDC_PutSector+0x62>
	{
		SSC_PutChar(Buffer[a]);
	}
	// write two bytes of crc16 to the sdcard
	SSC_PutChar((u8)(Crc16>>8)); 		// write high byte first
    183e:	8e 2d       	mov	r24, r14
    1840:	0e 94 8d 0c 	call	0x191a	; 0x191a <SSC_PutChar>
	SSC_PutChar((u8)(0x00FF&Crc16)); 	// lowbyte last
    1844:	8f 2d       	mov	r24, r15
    1846:	0e 94 8d 0c 	call	0x191a	; 0x191a <SSC_PutChar>
	SSC_ClearRxFifo();
    184a:	0e 94 86 0c 	call	0x190c	; 0x190c <SSC_ClearRxFifo>

SD_Result_t SDC_PutSector(u32 addr, const u8 *Buffer)
{
	u8 rsp; 
	
	u16 timeout = 0;
    184e:	c0 e0       	ldi	r28, 0x00	; 0
    1850:	d0 e0       	ldi	r29, 0x00	; 0
	SSC_PutChar((u8)(Crc16>>8)); 		// write high byte first
	SSC_PutChar((u8)(0x00FF&Crc16)); 	// lowbyte last
	SSC_ClearRxFifo();
	do							  		// wait for data response token
	{
	 	rsp = SSC_GetChar();
    1852:	0e 94 87 0c 	call	0x190e	; 0x190e <SSC_GetChar>
		if(timeout++>500) break;
    1856:	9e 01       	movw	r18, r28
    1858:	2f 5f       	subi	r18, 0xFF	; 255
    185a:	3f 4f       	sbci	r19, 0xFF	; 255
    185c:	c5 3f       	cpi	r28, 0xF5	; 245
    185e:	d1 40       	sbci	r29, 0x01	; 1
    1860:	28 f4       	brcc	.+10     	; 0x186c <SDC_PutSector+0xa6>
    1862:	e9 01       	movw	r28, r18
	}while((rsp & 0x11) != 0x01 );
    1864:	98 2f       	mov	r25, r24
    1866:	91 71       	andi	r25, 0x11	; 17
    1868:	91 30       	cpi	r25, 0x01	; 1
    186a:	99 f7       	brne	.-26     	; 0x1852 <SDC_PutSector+0x8c>
	// analyse data response token
	switch(rsp & DATA_RESPONSE_MASK)
    186c:	8f 71       	andi	r24, 0x1F	; 31
    186e:	8b 30       	cpi	r24, 0x0B	; 11
    1870:	29 f0       	breq	.+10     	; 0x187c <SDC_PutSector+0xb6>
    1872:	8d 31       	cpi	r24, 0x1D	; 29
    1874:	11 f1       	breq	.+68     	; 0x18ba <SDC_PutSector+0xf4>
    1876:	85 30       	cpi	r24, 0x05	; 5
    1878:	41 f4       	brne	.+16     	; 0x188a <SDC_PutSector+0xc4>
    187a:	02 c0       	rjmp	.+4      	; 0x1880 <SDC_PutSector+0xba>
	{
		case DATA_RESPONSE_OK:
			result = SD_SUCCESS;
			break;
		case DATA_RESPONSE_CRC_ERR:
			result = SD_ERROR_CRC_DATA;
    187c:	88 e0       	ldi	r24, 0x08	; 8
    187e:	22 c0       	rjmp	.+68     	; 0x18c4 <SDC_PutSector+0xfe>
			goto end;
			break;

	}
	// wait until the sdcard is busy.
	rsp = SDC_WaitForBusy();
    1880:	0e 94 7b 09 	call	0x12f6	; 0x12f6 <SDC_WaitForBusy>
	if(rsp != 0xFF)
    1884:	8f 3f       	cpi	r24, 0xFF	; 255
    1886:	d9 f4       	brne	.+54     	; 0x18be <SDC_PutSector+0xf8>
    1888:	02 c0       	rjmp	.+4      	; 0x188e <SDC_PutSector+0xc8>
		case DATA_RESPONSE_WRITE_ERR:
			result = SD_ERROR_WRITE_DATA;
			goto end;
			break;
		default:
			result = SD_ERROR_UNKNOWN;
    188a:	8c e0       	ldi	r24, 0x0C	; 12
			goto end;
    188c:	1b c0       	rjmp	.+54     	; 0x18c4 <SDC_PutSector+0xfe>
	{
	 	result =  SD_ERROR_TIMEOUT;
	 	goto end;
	}
	// check card status
	rsp = SDC_SendCMDR1(CMD_SEND_STATUS, 0);
    188e:	40 e0       	ldi	r20, 0x00	; 0
    1890:	50 e0       	ldi	r21, 0x00	; 0
    1892:	ba 01       	movw	r22, r20
    1894:	8d e0       	ldi	r24, 0x0D	; 13
    1896:	0e 94 91 09 	call	0x1322	; 0x1322 <SDC_SendCMDR1>
	if(rsp != R1_NO_ERR)
    189a:	88 23       	and	r24, r24
    189c:	21 f0       	breq	.+8      	; 0x18a6 <SDC_PutSector+0xe0>
	{
		result =  SD_ERROR_BAD_RESPONSE;
		SSC_GetChar();
    189e:	0e 94 87 0c 	call	0x190e	; 0x190e <SSC_GetChar>
	}
	// check card status
	rsp = SDC_SendCMDR1(CMD_SEND_STATUS, 0);
	if(rsp != R1_NO_ERR)
	{
		result =  SD_ERROR_BAD_RESPONSE;
    18a2:	84 e0       	ldi	r24, 0x04	; 4
		SSC_GetChar();
	 	goto end;
    18a4:	0f c0       	rjmp	.+30     	; 0x18c4 <SDC_PutSector+0xfe>
	}
	// 2nd byte of r2 response
	rsp = SSC_GetChar();
    18a6:	0e 94 87 0c 	call	0x190e	; 0x190e <SSC_GetChar>
	if(rsp != R2_NO_ERR)
    18aa:	88 23       	and	r24, r24
    18ac:	51 f0       	breq	.+20     	; 0x18c2 <SDC_PutSector+0xfc>
	{
		result =  SD_ERROR_WRITE_DATA;
		SSC_GetChar();
    18ae:	0e 94 87 0c 	call	0x190e	; 0x190e <SSC_GetChar>
	}
	// 2nd byte of r2 response
	rsp = SSC_GetChar();
	if(rsp != R2_NO_ERR)
	{
		result =  SD_ERROR_WRITE_DATA;
    18b2:	89 e0       	ldi	r24, 0x09	; 9
		SSC_GetChar();
	 	goto end;
    18b4:	07 c0       	rjmp	.+14     	; 0x18c4 <SDC_PutSector+0xfe>

	addr = addr << 9; // convert sectoradress to byteadress
	rsp = SDC_SendCMDR1(CMD_WRITE_SINGLE_BLOCK, addr);
	if (rsp != R1_NO_ERR)
	{
		result = SD_ERROR_BAD_RESPONSE;
    18b6:	84 e0       	ldi	r24, 0x04	; 4
    18b8:	05 c0       	rjmp	.+10     	; 0x18c4 <SDC_PutSector+0xfe>
		case DATA_RESPONSE_CRC_ERR:
			result = SD_ERROR_CRC_DATA;
			goto end;
			break;
		case DATA_RESPONSE_WRITE_ERR:
			result = SD_ERROR_WRITE_DATA;
    18ba:	89 e0       	ldi	r24, 0x09	; 9
    18bc:	03 c0       	rjmp	.+6      	; 0x18c4 <SDC_PutSector+0xfe>
	}
	// wait until the sdcard is busy.
	rsp = SDC_WaitForBusy();
	if(rsp != 0xFF)
	{
	 	result =  SD_ERROR_TIMEOUT;
    18be:	87 e0       	ldi	r24, 0x07	; 7
    18c0:	01 c0       	rjmp	.+2      	; 0x18c4 <SDC_PutSector+0xfe>
	}while((rsp & 0x11) != 0x01 );
	// analyse data response token
	switch(rsp & DATA_RESPONSE_MASK)
	{
		case DATA_RESPONSE_OK:
			result = SD_SUCCESS;
    18c2:	80 e0       	ldi	r24, 0x00	; 0
	 	goto end;
	}
	end:
	//SSC_Disable();						// disable sdcard.
	return(result);
} 
    18c4:	df 91       	pop	r29
    18c6:	cf 91       	pop	r28
    18c8:	1f 91       	pop	r17
    18ca:	0f 91       	pop	r16
    18cc:	ff 90       	pop	r15
    18ce:	ef 90       	pop	r14
    18d0:	08 95       	ret

000018d2 <SDC_GetSector>:
//
// Returnvalue: SD_Result_t
//________________________________________________________________________________________________________________________________________

SD_Result_t SDC_GetSector(u32 addr,u8 *Buffer)
{
    18d2:	ef 92       	push	r14
    18d4:	ff 92       	push	r15
    18d6:	0f 93       	push	r16
    18d8:	1f 93       	push	r17
    18da:	9a 01       	movw	r18, r20
	addr = addr << 9; // convert sectoradress to byteadress
    18dc:	ab 01       	movw	r20, r22
    18de:	bc 01       	movw	r22, r24
    18e0:	03 2e       	mov	r0, r19
    18e2:	39 e0       	ldi	r19, 0x09	; 9
    18e4:	44 0f       	add	r20, r20
    18e6:	55 1f       	adc	r21, r21
    18e8:	66 1f       	adc	r22, r22
    18ea:	77 1f       	adc	r23, r23
    18ec:	3a 95       	dec	r19
    18ee:	d1 f7       	brne	.-12     	; 0x18e4 <SDC_GetSector+0x12>
    18f0:	30 2d       	mov	r19, r0
	return SDC_GetData(CMD_READ_SINGLE_BLOCK, addr, Buffer, 512);
    18f2:	e1 2c       	mov	r14, r1
    18f4:	12 e0       	ldi	r17, 0x02	; 2
    18f6:	f1 2e       	mov	r15, r17
    18f8:	00 e0       	ldi	r16, 0x00	; 0
    18fa:	10 e0       	ldi	r17, 0x00	; 0
    18fc:	81 e1       	ldi	r24, 0x11	; 17
    18fe:	0e 94 04 0a 	call	0x1408	; 0x1408 <SDC_GetData>
}
    1902:	1f 91       	pop	r17
    1904:	0f 91       	pop	r16
    1906:	ff 90       	pop	r15
    1908:	ef 90       	pop	r14
    190a:	08 95       	ret

0000190c <SSC_ClearRxFifo>:
	SSC_Disable();													//               ___             ___
																	// data_________/   \___________/   \___________

																	// initialise ssc, clock = Idel low
																	// devide clock by 8
	SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR1); 							// Enable SSC in mastermode, invert clockpolarity (idle high)	
    190c:	08 95       	ret

0000190e <SSC_GetChar>:
    190e:	8f ef       	ldi	r24, 0xFF	; 255
    1910:	8f b9       	out	0x0f, r24	; 15
    1912:	77 9b       	sbis	0x0e, 7	; 14
    1914:	fe cf       	rjmp	.-4      	; 0x1912 <SSC_GetChar+0x4>
    1916:	8f b1       	in	r24, 0x0f	; 15
    1918:	08 95       	ret

0000191a <SSC_PutChar>:
    191a:	8f b9       	out	0x0f, r24	; 15
    191c:	77 9b       	sbis	0x0e, 7	; 14
    191e:	fe cf       	rjmp	.-4      	; 0x191c <SSC_PutChar+0x2>
    1920:	08 95       	ret

00001922 <SSC_Disable>:
    1922:	85 b3       	in	r24, 0x15	; 21
    1924:	80 68       	ori	r24, 0x80	; 128
    1926:	85 bb       	out	0x15, r24	; 21
    1928:	08 95       	ret

0000192a <SSC_Init>:
    192a:	87 b3       	in	r24, 0x17	; 23
    192c:	8f 7b       	andi	r24, 0xBF	; 191
    192e:	87 bb       	out	0x17, r24	; 23
    1930:	87 b3       	in	r24, 0x17	; 23
    1932:	80 68       	ori	r24, 0x80	; 128
    1934:	87 bb       	out	0x17, r24	; 23
    1936:	87 b3       	in	r24, 0x17	; 23
    1938:	80 62       	ori	r24, 0x20	; 32
    193a:	87 bb       	out	0x17, r24	; 23
    193c:	84 b3       	in	r24, 0x14	; 20
    193e:	80 68       	ori	r24, 0x80	; 128
    1940:	84 bb       	out	0x14, r24	; 20
    1942:	87 b3       	in	r24, 0x17	; 23
    1944:	80 61       	ori	r24, 0x10	; 16
    1946:	87 bb       	out	0x17, r24	; 23
    1948:	0e 94 91 0c 	call	0x1922	; 0x1922 <SSC_Disable>
    194c:	82 e5       	ldi	r24, 0x52	; 82
    194e:	8d b9       	out	0x0d, r24	; 13
    1950:	08 95       	ret

00001952 <SSC_Enable>:
void SSC_Enable(void) 
{ 
	#ifdef __MMC_INTERFACE_INVERTED
	MMCS_Write |= (1<<MMC_Chip_Select); 					// enable chipselect of the sdcard (active low). 
	#else
	MMCS_Write &= ~(1<<MMC_Chip_Select);					// disable chipselect of the sdcard (active low). 
    1952:	85 b3       	in	r24, 0x15	; 21
    1954:	8f 77       	andi	r24, 0x7F	; 127
    1956:	85 bb       	out	0x15, r24	; 21
    1958:	08 95       	ret

0000195a <__udivmodsi4>:
    195a:	a1 e2       	ldi	r26, 0x21	; 33
    195c:	1a 2e       	mov	r1, r26
    195e:	aa 1b       	sub	r26, r26
    1960:	bb 1b       	sub	r27, r27
    1962:	fd 01       	movw	r30, r26
    1964:	0d c0       	rjmp	.+26     	; 0x1980 <__udivmodsi4_ep>

00001966 <__udivmodsi4_loop>:
    1966:	aa 1f       	adc	r26, r26
    1968:	bb 1f       	adc	r27, r27
    196a:	ee 1f       	adc	r30, r30
    196c:	ff 1f       	adc	r31, r31
    196e:	a2 17       	cp	r26, r18
    1970:	b3 07       	cpc	r27, r19
    1972:	e4 07       	cpc	r30, r20
    1974:	f5 07       	cpc	r31, r21
    1976:	20 f0       	brcs	.+8      	; 0x1980 <__udivmodsi4_ep>
    1978:	a2 1b       	sub	r26, r18
    197a:	b3 0b       	sbc	r27, r19
    197c:	e4 0b       	sbc	r30, r20
    197e:	f5 0b       	sbc	r31, r21

00001980 <__udivmodsi4_ep>:
    1980:	66 1f       	adc	r22, r22
    1982:	77 1f       	adc	r23, r23
    1984:	88 1f       	adc	r24, r24
    1986:	99 1f       	adc	r25, r25
    1988:	1a 94       	dec	r1
    198a:	69 f7       	brne	.-38     	; 0x1966 <__udivmodsi4_loop>
    198c:	60 95       	com	r22
    198e:	70 95       	com	r23
    1990:	80 95       	com	r24
    1992:	90 95       	com	r25
    1994:	9b 01       	movw	r18, r22
    1996:	ac 01       	movw	r20, r24
    1998:	bd 01       	movw	r22, r26
    199a:	cf 01       	movw	r24, r30
    199c:	08 95       	ret

0000199e <__umulhisi3>:
    199e:	a2 9f       	mul	r26, r18
    19a0:	b0 01       	movw	r22, r0
    19a2:	b3 9f       	mul	r27, r19
    19a4:	c0 01       	movw	r24, r0
    19a6:	a3 9f       	mul	r26, r19
    19a8:	70 0d       	add	r23, r0
    19aa:	81 1d       	adc	r24, r1
    19ac:	11 24       	eor	r1, r1
    19ae:	91 1d       	adc	r25, r1
    19b0:	b2 9f       	mul	r27, r18
    19b2:	70 0d       	add	r23, r0
    19b4:	81 1d       	adc	r24, r1
    19b6:	11 24       	eor	r1, r1
    19b8:	91 1d       	adc	r25, r1
    19ba:	08 95       	ret

000019bc <__muluhisi3>:
    19bc:	0e 94 cf 0c 	call	0x199e	; 0x199e <__umulhisi3>
    19c0:	a5 9f       	mul	r26, r21
    19c2:	90 0d       	add	r25, r0
    19c4:	b4 9f       	mul	r27, r20
    19c6:	90 0d       	add	r25, r0
    19c8:	a4 9f       	mul	r26, r20
    19ca:	80 0d       	add	r24, r0
    19cc:	91 1d       	adc	r25, r1
    19ce:	11 24       	eor	r1, r1
    19d0:	08 95       	ret

000019d2 <printf>:
    19d2:	a0 e0       	ldi	r26, 0x00	; 0
    19d4:	b0 e0       	ldi	r27, 0x00	; 0
    19d6:	ef ee       	ldi	r30, 0xEF	; 239
    19d8:	fc e0       	ldi	r31, 0x0C	; 12
    19da:	0c 94 a0 0f 	jmp	0x1f40	; 0x1f40 <__prologue_saves__+0x20>
    19de:	ae 01       	movw	r20, r28
    19e0:	4b 5f       	subi	r20, 0xFB	; 251
    19e2:	5f 4f       	sbci	r21, 0xFF	; 255
    19e4:	fa 01       	movw	r30, r20
    19e6:	61 91       	ld	r22, Z+
    19e8:	71 91       	ld	r23, Z+
    19ea:	af 01       	movw	r20, r30
    19ec:	80 91 8e 05 	lds	r24, 0x058E	; 0x80058e <__iob+0x2>
    19f0:	90 91 8f 05 	lds	r25, 0x058F	; 0x80058f <__iob+0x3>
    19f4:	0e 94 ff 0c 	call	0x19fe	; 0x19fe <vfprintf>
    19f8:	e2 e0       	ldi	r30, 0x02	; 2
    19fa:	0c 94 bc 0f 	jmp	0x1f78	; 0x1f78 <__epilogue_restores__+0x20>

000019fe <vfprintf>:
    19fe:	ab e0       	ldi	r26, 0x0B	; 11
    1a00:	b0 e0       	ldi	r27, 0x00	; 0
    1a02:	e5 e0       	ldi	r30, 0x05	; 5
    1a04:	fd e0       	ldi	r31, 0x0D	; 13
    1a06:	0c 94 90 0f 	jmp	0x1f20	; 0x1f20 <__prologue_saves__>
    1a0a:	6c 01       	movw	r12, r24
    1a0c:	7b 01       	movw	r14, r22
    1a0e:	8a 01       	movw	r16, r20
    1a10:	fc 01       	movw	r30, r24
    1a12:	17 82       	std	Z+7, r1	; 0x07
    1a14:	16 82       	std	Z+6, r1	; 0x06
    1a16:	83 81       	ldd	r24, Z+3	; 0x03
    1a18:	81 ff       	sbrs	r24, 1
    1a1a:	cc c1       	rjmp	.+920    	; 0x1db4 <vfprintf+0x3b6>
    1a1c:	ce 01       	movw	r24, r28
    1a1e:	01 96       	adiw	r24, 0x01	; 1
    1a20:	3c 01       	movw	r6, r24
    1a22:	f6 01       	movw	r30, r12
    1a24:	93 81       	ldd	r25, Z+3	; 0x03
    1a26:	f7 01       	movw	r30, r14
    1a28:	93 fd       	sbrc	r25, 3
    1a2a:	85 91       	lpm	r24, Z+
    1a2c:	93 ff       	sbrs	r25, 3
    1a2e:	81 91       	ld	r24, Z+
    1a30:	7f 01       	movw	r14, r30
    1a32:	88 23       	and	r24, r24
    1a34:	09 f4       	brne	.+2      	; 0x1a38 <vfprintf+0x3a>
    1a36:	ba c1       	rjmp	.+884    	; 0x1dac <vfprintf+0x3ae>
    1a38:	85 32       	cpi	r24, 0x25	; 37
    1a3a:	39 f4       	brne	.+14     	; 0x1a4a <vfprintf+0x4c>
    1a3c:	93 fd       	sbrc	r25, 3
    1a3e:	85 91       	lpm	r24, Z+
    1a40:	93 ff       	sbrs	r25, 3
    1a42:	81 91       	ld	r24, Z+
    1a44:	7f 01       	movw	r14, r30
    1a46:	85 32       	cpi	r24, 0x25	; 37
    1a48:	29 f4       	brne	.+10     	; 0x1a54 <vfprintf+0x56>
    1a4a:	b6 01       	movw	r22, r12
    1a4c:	90 e0       	ldi	r25, 0x00	; 0
    1a4e:	0e 94 f6 0e 	call	0x1dec	; 0x1dec <fputc>
    1a52:	e7 cf       	rjmp	.-50     	; 0x1a22 <vfprintf+0x24>
    1a54:	91 2c       	mov	r9, r1
    1a56:	21 2c       	mov	r2, r1
    1a58:	31 2c       	mov	r3, r1
    1a5a:	ff e1       	ldi	r31, 0x1F	; 31
    1a5c:	f3 15       	cp	r31, r3
    1a5e:	d8 f0       	brcs	.+54     	; 0x1a96 <vfprintf+0x98>
    1a60:	8b 32       	cpi	r24, 0x2B	; 43
    1a62:	79 f0       	breq	.+30     	; 0x1a82 <vfprintf+0x84>
    1a64:	38 f4       	brcc	.+14     	; 0x1a74 <vfprintf+0x76>
    1a66:	80 32       	cpi	r24, 0x20	; 32
    1a68:	79 f0       	breq	.+30     	; 0x1a88 <vfprintf+0x8a>
    1a6a:	83 32       	cpi	r24, 0x23	; 35
    1a6c:	a1 f4       	brne	.+40     	; 0x1a96 <vfprintf+0x98>
    1a6e:	23 2d       	mov	r18, r3
    1a70:	20 61       	ori	r18, 0x10	; 16
    1a72:	1d c0       	rjmp	.+58     	; 0x1aae <vfprintf+0xb0>
    1a74:	8d 32       	cpi	r24, 0x2D	; 45
    1a76:	61 f0       	breq	.+24     	; 0x1a90 <vfprintf+0x92>
    1a78:	80 33       	cpi	r24, 0x30	; 48
    1a7a:	69 f4       	brne	.+26     	; 0x1a96 <vfprintf+0x98>
    1a7c:	23 2d       	mov	r18, r3
    1a7e:	21 60       	ori	r18, 0x01	; 1
    1a80:	16 c0       	rjmp	.+44     	; 0x1aae <vfprintf+0xb0>
    1a82:	83 2d       	mov	r24, r3
    1a84:	82 60       	ori	r24, 0x02	; 2
    1a86:	38 2e       	mov	r3, r24
    1a88:	e3 2d       	mov	r30, r3
    1a8a:	e4 60       	ori	r30, 0x04	; 4
    1a8c:	3e 2e       	mov	r3, r30
    1a8e:	2a c0       	rjmp	.+84     	; 0x1ae4 <vfprintf+0xe6>
    1a90:	f3 2d       	mov	r31, r3
    1a92:	f8 60       	ori	r31, 0x08	; 8
    1a94:	1d c0       	rjmp	.+58     	; 0x1ad0 <vfprintf+0xd2>
    1a96:	37 fc       	sbrc	r3, 7
    1a98:	2d c0       	rjmp	.+90     	; 0x1af4 <vfprintf+0xf6>
    1a9a:	20 ed       	ldi	r18, 0xD0	; 208
    1a9c:	28 0f       	add	r18, r24
    1a9e:	2a 30       	cpi	r18, 0x0A	; 10
    1aa0:	40 f0       	brcs	.+16     	; 0x1ab2 <vfprintf+0xb4>
    1aa2:	8e 32       	cpi	r24, 0x2E	; 46
    1aa4:	b9 f4       	brne	.+46     	; 0x1ad4 <vfprintf+0xd6>
    1aa6:	36 fc       	sbrc	r3, 6
    1aa8:	81 c1       	rjmp	.+770    	; 0x1dac <vfprintf+0x3ae>
    1aaa:	23 2d       	mov	r18, r3
    1aac:	20 64       	ori	r18, 0x40	; 64
    1aae:	32 2e       	mov	r3, r18
    1ab0:	19 c0       	rjmp	.+50     	; 0x1ae4 <vfprintf+0xe6>
    1ab2:	36 fe       	sbrs	r3, 6
    1ab4:	06 c0       	rjmp	.+12     	; 0x1ac2 <vfprintf+0xc4>
    1ab6:	8a e0       	ldi	r24, 0x0A	; 10
    1ab8:	98 9e       	mul	r9, r24
    1aba:	20 0d       	add	r18, r0
    1abc:	11 24       	eor	r1, r1
    1abe:	92 2e       	mov	r9, r18
    1ac0:	11 c0       	rjmp	.+34     	; 0x1ae4 <vfprintf+0xe6>
    1ac2:	ea e0       	ldi	r30, 0x0A	; 10
    1ac4:	2e 9e       	mul	r2, r30
    1ac6:	20 0d       	add	r18, r0
    1ac8:	11 24       	eor	r1, r1
    1aca:	22 2e       	mov	r2, r18
    1acc:	f3 2d       	mov	r31, r3
    1ace:	f0 62       	ori	r31, 0x20	; 32
    1ad0:	3f 2e       	mov	r3, r31
    1ad2:	08 c0       	rjmp	.+16     	; 0x1ae4 <vfprintf+0xe6>
    1ad4:	8c 36       	cpi	r24, 0x6C	; 108
    1ad6:	21 f4       	brne	.+8      	; 0x1ae0 <vfprintf+0xe2>
    1ad8:	83 2d       	mov	r24, r3
    1ada:	80 68       	ori	r24, 0x80	; 128
    1adc:	38 2e       	mov	r3, r24
    1ade:	02 c0       	rjmp	.+4      	; 0x1ae4 <vfprintf+0xe6>
    1ae0:	88 36       	cpi	r24, 0x68	; 104
    1ae2:	41 f4       	brne	.+16     	; 0x1af4 <vfprintf+0xf6>
    1ae4:	f7 01       	movw	r30, r14
    1ae6:	93 fd       	sbrc	r25, 3
    1ae8:	85 91       	lpm	r24, Z+
    1aea:	93 ff       	sbrs	r25, 3
    1aec:	81 91       	ld	r24, Z+
    1aee:	7f 01       	movw	r14, r30
    1af0:	81 11       	cpse	r24, r1
    1af2:	b3 cf       	rjmp	.-154    	; 0x1a5a <vfprintf+0x5c>
    1af4:	98 2f       	mov	r25, r24
    1af6:	9f 7d       	andi	r25, 0xDF	; 223
    1af8:	95 54       	subi	r25, 0x45	; 69
    1afa:	93 30       	cpi	r25, 0x03	; 3
    1afc:	28 f4       	brcc	.+10     	; 0x1b08 <vfprintf+0x10a>
    1afe:	0c 5f       	subi	r16, 0xFC	; 252
    1b00:	1f 4f       	sbci	r17, 0xFF	; 255
    1b02:	9f e3       	ldi	r25, 0x3F	; 63
    1b04:	99 83       	std	Y+1, r25	; 0x01
    1b06:	0d c0       	rjmp	.+26     	; 0x1b22 <vfprintf+0x124>
    1b08:	83 36       	cpi	r24, 0x63	; 99
    1b0a:	31 f0       	breq	.+12     	; 0x1b18 <vfprintf+0x11a>
    1b0c:	83 37       	cpi	r24, 0x73	; 115
    1b0e:	71 f0       	breq	.+28     	; 0x1b2c <vfprintf+0x12e>
    1b10:	83 35       	cpi	r24, 0x53	; 83
    1b12:	09 f0       	breq	.+2      	; 0x1b16 <vfprintf+0x118>
    1b14:	59 c0       	rjmp	.+178    	; 0x1bc8 <vfprintf+0x1ca>
    1b16:	21 c0       	rjmp	.+66     	; 0x1b5a <vfprintf+0x15c>
    1b18:	f8 01       	movw	r30, r16
    1b1a:	80 81       	ld	r24, Z
    1b1c:	89 83       	std	Y+1, r24	; 0x01
    1b1e:	0e 5f       	subi	r16, 0xFE	; 254
    1b20:	1f 4f       	sbci	r17, 0xFF	; 255
    1b22:	88 24       	eor	r8, r8
    1b24:	83 94       	inc	r8
    1b26:	91 2c       	mov	r9, r1
    1b28:	53 01       	movw	r10, r6
    1b2a:	13 c0       	rjmp	.+38     	; 0x1b52 <vfprintf+0x154>
    1b2c:	28 01       	movw	r4, r16
    1b2e:	f2 e0       	ldi	r31, 0x02	; 2
    1b30:	4f 0e       	add	r4, r31
    1b32:	51 1c       	adc	r5, r1
    1b34:	f8 01       	movw	r30, r16
    1b36:	a0 80       	ld	r10, Z
    1b38:	b1 80       	ldd	r11, Z+1	; 0x01
    1b3a:	36 fe       	sbrs	r3, 6
    1b3c:	03 c0       	rjmp	.+6      	; 0x1b44 <vfprintf+0x146>
    1b3e:	69 2d       	mov	r22, r9
    1b40:	70 e0       	ldi	r23, 0x00	; 0
    1b42:	02 c0       	rjmp	.+4      	; 0x1b48 <vfprintf+0x14a>
    1b44:	6f ef       	ldi	r22, 0xFF	; 255
    1b46:	7f ef       	ldi	r23, 0xFF	; 255
    1b48:	c5 01       	movw	r24, r10
    1b4a:	0e 94 eb 0e 	call	0x1dd6	; 0x1dd6 <strnlen>
    1b4e:	4c 01       	movw	r8, r24
    1b50:	82 01       	movw	r16, r4
    1b52:	f3 2d       	mov	r31, r3
    1b54:	ff 77       	andi	r31, 0x7F	; 127
    1b56:	3f 2e       	mov	r3, r31
    1b58:	16 c0       	rjmp	.+44     	; 0x1b86 <vfprintf+0x188>
    1b5a:	28 01       	movw	r4, r16
    1b5c:	22 e0       	ldi	r18, 0x02	; 2
    1b5e:	42 0e       	add	r4, r18
    1b60:	51 1c       	adc	r5, r1
    1b62:	f8 01       	movw	r30, r16
    1b64:	a0 80       	ld	r10, Z
    1b66:	b1 80       	ldd	r11, Z+1	; 0x01
    1b68:	36 fe       	sbrs	r3, 6
    1b6a:	03 c0       	rjmp	.+6      	; 0x1b72 <vfprintf+0x174>
    1b6c:	69 2d       	mov	r22, r9
    1b6e:	70 e0       	ldi	r23, 0x00	; 0
    1b70:	02 c0       	rjmp	.+4      	; 0x1b76 <vfprintf+0x178>
    1b72:	6f ef       	ldi	r22, 0xFF	; 255
    1b74:	7f ef       	ldi	r23, 0xFF	; 255
    1b76:	c5 01       	movw	r24, r10
    1b78:	0e 94 e0 0e 	call	0x1dc0	; 0x1dc0 <strnlen_P>
    1b7c:	4c 01       	movw	r8, r24
    1b7e:	f3 2d       	mov	r31, r3
    1b80:	f0 68       	ori	r31, 0x80	; 128
    1b82:	3f 2e       	mov	r3, r31
    1b84:	82 01       	movw	r16, r4
    1b86:	33 fc       	sbrc	r3, 3
    1b88:	1b c0       	rjmp	.+54     	; 0x1bc0 <vfprintf+0x1c2>
    1b8a:	82 2d       	mov	r24, r2
    1b8c:	90 e0       	ldi	r25, 0x00	; 0
    1b8e:	88 16       	cp	r8, r24
    1b90:	99 06       	cpc	r9, r25
    1b92:	b0 f4       	brcc	.+44     	; 0x1bc0 <vfprintf+0x1c2>
    1b94:	b6 01       	movw	r22, r12
    1b96:	80 e2       	ldi	r24, 0x20	; 32
    1b98:	90 e0       	ldi	r25, 0x00	; 0
    1b9a:	0e 94 f6 0e 	call	0x1dec	; 0x1dec <fputc>
    1b9e:	2a 94       	dec	r2
    1ba0:	f4 cf       	rjmp	.-24     	; 0x1b8a <vfprintf+0x18c>
    1ba2:	f5 01       	movw	r30, r10
    1ba4:	37 fc       	sbrc	r3, 7
    1ba6:	85 91       	lpm	r24, Z+
    1ba8:	37 fe       	sbrs	r3, 7
    1baa:	81 91       	ld	r24, Z+
    1bac:	5f 01       	movw	r10, r30
    1bae:	b6 01       	movw	r22, r12
    1bb0:	90 e0       	ldi	r25, 0x00	; 0
    1bb2:	0e 94 f6 0e 	call	0x1dec	; 0x1dec <fputc>
    1bb6:	21 10       	cpse	r2, r1
    1bb8:	2a 94       	dec	r2
    1bba:	21 e0       	ldi	r18, 0x01	; 1
    1bbc:	82 1a       	sub	r8, r18
    1bbe:	91 08       	sbc	r9, r1
    1bc0:	81 14       	cp	r8, r1
    1bc2:	91 04       	cpc	r9, r1
    1bc4:	71 f7       	brne	.-36     	; 0x1ba2 <vfprintf+0x1a4>
    1bc6:	e8 c0       	rjmp	.+464    	; 0x1d98 <vfprintf+0x39a>
    1bc8:	84 36       	cpi	r24, 0x64	; 100
    1bca:	11 f0       	breq	.+4      	; 0x1bd0 <vfprintf+0x1d2>
    1bcc:	89 36       	cpi	r24, 0x69	; 105
    1bce:	41 f5       	brne	.+80     	; 0x1c20 <vfprintf+0x222>
    1bd0:	f8 01       	movw	r30, r16
    1bd2:	37 fe       	sbrs	r3, 7
    1bd4:	07 c0       	rjmp	.+14     	; 0x1be4 <vfprintf+0x1e6>
    1bd6:	60 81       	ld	r22, Z
    1bd8:	71 81       	ldd	r23, Z+1	; 0x01
    1bda:	82 81       	ldd	r24, Z+2	; 0x02
    1bdc:	93 81       	ldd	r25, Z+3	; 0x03
    1bde:	0c 5f       	subi	r16, 0xFC	; 252
    1be0:	1f 4f       	sbci	r17, 0xFF	; 255
    1be2:	08 c0       	rjmp	.+16     	; 0x1bf4 <vfprintf+0x1f6>
    1be4:	60 81       	ld	r22, Z
    1be6:	71 81       	ldd	r23, Z+1	; 0x01
    1be8:	07 2e       	mov	r0, r23
    1bea:	00 0c       	add	r0, r0
    1bec:	88 0b       	sbc	r24, r24
    1bee:	99 0b       	sbc	r25, r25
    1bf0:	0e 5f       	subi	r16, 0xFE	; 254
    1bf2:	1f 4f       	sbci	r17, 0xFF	; 255
    1bf4:	f3 2d       	mov	r31, r3
    1bf6:	ff 76       	andi	r31, 0x6F	; 111
    1bf8:	3f 2e       	mov	r3, r31
    1bfa:	97 ff       	sbrs	r25, 7
    1bfc:	09 c0       	rjmp	.+18     	; 0x1c10 <vfprintf+0x212>
    1bfe:	90 95       	com	r25
    1c00:	80 95       	com	r24
    1c02:	70 95       	com	r23
    1c04:	61 95       	neg	r22
    1c06:	7f 4f       	sbci	r23, 0xFF	; 255
    1c08:	8f 4f       	sbci	r24, 0xFF	; 255
    1c0a:	9f 4f       	sbci	r25, 0xFF	; 255
    1c0c:	f0 68       	ori	r31, 0x80	; 128
    1c0e:	3f 2e       	mov	r3, r31
    1c10:	2a e0       	ldi	r18, 0x0A	; 10
    1c12:	30 e0       	ldi	r19, 0x00	; 0
    1c14:	a3 01       	movw	r20, r6
    1c16:	0e 94 32 0f 	call	0x1e64	; 0x1e64 <__ultoa_invert>
    1c1a:	88 2e       	mov	r8, r24
    1c1c:	86 18       	sub	r8, r6
    1c1e:	45 c0       	rjmp	.+138    	; 0x1caa <vfprintf+0x2ac>
    1c20:	85 37       	cpi	r24, 0x75	; 117
    1c22:	31 f4       	brne	.+12     	; 0x1c30 <vfprintf+0x232>
    1c24:	23 2d       	mov	r18, r3
    1c26:	2f 7e       	andi	r18, 0xEF	; 239
    1c28:	b2 2e       	mov	r11, r18
    1c2a:	2a e0       	ldi	r18, 0x0A	; 10
    1c2c:	30 e0       	ldi	r19, 0x00	; 0
    1c2e:	25 c0       	rjmp	.+74     	; 0x1c7a <vfprintf+0x27c>
    1c30:	93 2d       	mov	r25, r3
    1c32:	99 7f       	andi	r25, 0xF9	; 249
    1c34:	b9 2e       	mov	r11, r25
    1c36:	8f 36       	cpi	r24, 0x6F	; 111
    1c38:	c1 f0       	breq	.+48     	; 0x1c6a <vfprintf+0x26c>
    1c3a:	18 f4       	brcc	.+6      	; 0x1c42 <vfprintf+0x244>
    1c3c:	88 35       	cpi	r24, 0x58	; 88
    1c3e:	79 f0       	breq	.+30     	; 0x1c5e <vfprintf+0x260>
    1c40:	b5 c0       	rjmp	.+362    	; 0x1dac <vfprintf+0x3ae>
    1c42:	80 37       	cpi	r24, 0x70	; 112
    1c44:	19 f0       	breq	.+6      	; 0x1c4c <vfprintf+0x24e>
    1c46:	88 37       	cpi	r24, 0x78	; 120
    1c48:	21 f0       	breq	.+8      	; 0x1c52 <vfprintf+0x254>
    1c4a:	b0 c0       	rjmp	.+352    	; 0x1dac <vfprintf+0x3ae>
    1c4c:	e9 2f       	mov	r30, r25
    1c4e:	e0 61       	ori	r30, 0x10	; 16
    1c50:	be 2e       	mov	r11, r30
    1c52:	b4 fe       	sbrs	r11, 4
    1c54:	0d c0       	rjmp	.+26     	; 0x1c70 <vfprintf+0x272>
    1c56:	fb 2d       	mov	r31, r11
    1c58:	f4 60       	ori	r31, 0x04	; 4
    1c5a:	bf 2e       	mov	r11, r31
    1c5c:	09 c0       	rjmp	.+18     	; 0x1c70 <vfprintf+0x272>
    1c5e:	34 fe       	sbrs	r3, 4
    1c60:	0a c0       	rjmp	.+20     	; 0x1c76 <vfprintf+0x278>
    1c62:	29 2f       	mov	r18, r25
    1c64:	26 60       	ori	r18, 0x06	; 6
    1c66:	b2 2e       	mov	r11, r18
    1c68:	06 c0       	rjmp	.+12     	; 0x1c76 <vfprintf+0x278>
    1c6a:	28 e0       	ldi	r18, 0x08	; 8
    1c6c:	30 e0       	ldi	r19, 0x00	; 0
    1c6e:	05 c0       	rjmp	.+10     	; 0x1c7a <vfprintf+0x27c>
    1c70:	20 e1       	ldi	r18, 0x10	; 16
    1c72:	30 e0       	ldi	r19, 0x00	; 0
    1c74:	02 c0       	rjmp	.+4      	; 0x1c7a <vfprintf+0x27c>
    1c76:	20 e1       	ldi	r18, 0x10	; 16
    1c78:	32 e0       	ldi	r19, 0x02	; 2
    1c7a:	f8 01       	movw	r30, r16
    1c7c:	b7 fe       	sbrs	r11, 7
    1c7e:	07 c0       	rjmp	.+14     	; 0x1c8e <vfprintf+0x290>
    1c80:	60 81       	ld	r22, Z
    1c82:	71 81       	ldd	r23, Z+1	; 0x01
    1c84:	82 81       	ldd	r24, Z+2	; 0x02
    1c86:	93 81       	ldd	r25, Z+3	; 0x03
    1c88:	0c 5f       	subi	r16, 0xFC	; 252
    1c8a:	1f 4f       	sbci	r17, 0xFF	; 255
    1c8c:	06 c0       	rjmp	.+12     	; 0x1c9a <vfprintf+0x29c>
    1c8e:	60 81       	ld	r22, Z
    1c90:	71 81       	ldd	r23, Z+1	; 0x01
    1c92:	80 e0       	ldi	r24, 0x00	; 0
    1c94:	90 e0       	ldi	r25, 0x00	; 0
    1c96:	0e 5f       	subi	r16, 0xFE	; 254
    1c98:	1f 4f       	sbci	r17, 0xFF	; 255
    1c9a:	a3 01       	movw	r20, r6
    1c9c:	0e 94 32 0f 	call	0x1e64	; 0x1e64 <__ultoa_invert>
    1ca0:	88 2e       	mov	r8, r24
    1ca2:	86 18       	sub	r8, r6
    1ca4:	fb 2d       	mov	r31, r11
    1ca6:	ff 77       	andi	r31, 0x7F	; 127
    1ca8:	3f 2e       	mov	r3, r31
    1caa:	36 fe       	sbrs	r3, 6
    1cac:	0d c0       	rjmp	.+26     	; 0x1cc8 <vfprintf+0x2ca>
    1cae:	23 2d       	mov	r18, r3
    1cb0:	2e 7f       	andi	r18, 0xFE	; 254
    1cb2:	a2 2e       	mov	r10, r18
    1cb4:	89 14       	cp	r8, r9
    1cb6:	58 f4       	brcc	.+22     	; 0x1cce <vfprintf+0x2d0>
    1cb8:	34 fe       	sbrs	r3, 4
    1cba:	0b c0       	rjmp	.+22     	; 0x1cd2 <vfprintf+0x2d4>
    1cbc:	32 fc       	sbrc	r3, 2
    1cbe:	09 c0       	rjmp	.+18     	; 0x1cd2 <vfprintf+0x2d4>
    1cc0:	83 2d       	mov	r24, r3
    1cc2:	8e 7e       	andi	r24, 0xEE	; 238
    1cc4:	a8 2e       	mov	r10, r24
    1cc6:	05 c0       	rjmp	.+10     	; 0x1cd2 <vfprintf+0x2d4>
    1cc8:	b8 2c       	mov	r11, r8
    1cca:	a3 2c       	mov	r10, r3
    1ccc:	03 c0       	rjmp	.+6      	; 0x1cd4 <vfprintf+0x2d6>
    1cce:	b8 2c       	mov	r11, r8
    1cd0:	01 c0       	rjmp	.+2      	; 0x1cd4 <vfprintf+0x2d6>
    1cd2:	b9 2c       	mov	r11, r9
    1cd4:	a4 fe       	sbrs	r10, 4
    1cd6:	0f c0       	rjmp	.+30     	; 0x1cf6 <vfprintf+0x2f8>
    1cd8:	fe 01       	movw	r30, r28
    1cda:	e8 0d       	add	r30, r8
    1cdc:	f1 1d       	adc	r31, r1
    1cde:	80 81       	ld	r24, Z
    1ce0:	80 33       	cpi	r24, 0x30	; 48
    1ce2:	21 f4       	brne	.+8      	; 0x1cec <vfprintf+0x2ee>
    1ce4:	9a 2d       	mov	r25, r10
    1ce6:	99 7e       	andi	r25, 0xE9	; 233
    1ce8:	a9 2e       	mov	r10, r25
    1cea:	09 c0       	rjmp	.+18     	; 0x1cfe <vfprintf+0x300>
    1cec:	a2 fe       	sbrs	r10, 2
    1cee:	06 c0       	rjmp	.+12     	; 0x1cfc <vfprintf+0x2fe>
    1cf0:	b3 94       	inc	r11
    1cf2:	b3 94       	inc	r11
    1cf4:	04 c0       	rjmp	.+8      	; 0x1cfe <vfprintf+0x300>
    1cf6:	8a 2d       	mov	r24, r10
    1cf8:	86 78       	andi	r24, 0x86	; 134
    1cfa:	09 f0       	breq	.+2      	; 0x1cfe <vfprintf+0x300>
    1cfc:	b3 94       	inc	r11
    1cfe:	a3 fc       	sbrc	r10, 3
    1d00:	11 c0       	rjmp	.+34     	; 0x1d24 <vfprintf+0x326>
    1d02:	a0 fe       	sbrs	r10, 0
    1d04:	06 c0       	rjmp	.+12     	; 0x1d12 <vfprintf+0x314>
    1d06:	b2 14       	cp	r11, r2
    1d08:	88 f4       	brcc	.+34     	; 0x1d2c <vfprintf+0x32e>
    1d0a:	28 0c       	add	r2, r8
    1d0c:	92 2c       	mov	r9, r2
    1d0e:	9b 18       	sub	r9, r11
    1d10:	0e c0       	rjmp	.+28     	; 0x1d2e <vfprintf+0x330>
    1d12:	b2 14       	cp	r11, r2
    1d14:	60 f4       	brcc	.+24     	; 0x1d2e <vfprintf+0x330>
    1d16:	b6 01       	movw	r22, r12
    1d18:	80 e2       	ldi	r24, 0x20	; 32
    1d1a:	90 e0       	ldi	r25, 0x00	; 0
    1d1c:	0e 94 f6 0e 	call	0x1dec	; 0x1dec <fputc>
    1d20:	b3 94       	inc	r11
    1d22:	f7 cf       	rjmp	.-18     	; 0x1d12 <vfprintf+0x314>
    1d24:	b2 14       	cp	r11, r2
    1d26:	18 f4       	brcc	.+6      	; 0x1d2e <vfprintf+0x330>
    1d28:	2b 18       	sub	r2, r11
    1d2a:	02 c0       	rjmp	.+4      	; 0x1d30 <vfprintf+0x332>
    1d2c:	98 2c       	mov	r9, r8
    1d2e:	21 2c       	mov	r2, r1
    1d30:	a4 fe       	sbrs	r10, 4
    1d32:	10 c0       	rjmp	.+32     	; 0x1d54 <vfprintf+0x356>
    1d34:	b6 01       	movw	r22, r12
    1d36:	80 e3       	ldi	r24, 0x30	; 48
    1d38:	90 e0       	ldi	r25, 0x00	; 0
    1d3a:	0e 94 f6 0e 	call	0x1dec	; 0x1dec <fputc>
    1d3e:	a2 fe       	sbrs	r10, 2
    1d40:	17 c0       	rjmp	.+46     	; 0x1d70 <vfprintf+0x372>
    1d42:	a1 fc       	sbrc	r10, 1
    1d44:	03 c0       	rjmp	.+6      	; 0x1d4c <vfprintf+0x34e>
    1d46:	88 e7       	ldi	r24, 0x78	; 120
    1d48:	90 e0       	ldi	r25, 0x00	; 0
    1d4a:	02 c0       	rjmp	.+4      	; 0x1d50 <vfprintf+0x352>
    1d4c:	88 e5       	ldi	r24, 0x58	; 88
    1d4e:	90 e0       	ldi	r25, 0x00	; 0
    1d50:	b6 01       	movw	r22, r12
    1d52:	0c c0       	rjmp	.+24     	; 0x1d6c <vfprintf+0x36e>
    1d54:	8a 2d       	mov	r24, r10
    1d56:	86 78       	andi	r24, 0x86	; 134
    1d58:	59 f0       	breq	.+22     	; 0x1d70 <vfprintf+0x372>
    1d5a:	a1 fe       	sbrs	r10, 1
    1d5c:	02 c0       	rjmp	.+4      	; 0x1d62 <vfprintf+0x364>
    1d5e:	8b e2       	ldi	r24, 0x2B	; 43
    1d60:	01 c0       	rjmp	.+2      	; 0x1d64 <vfprintf+0x366>
    1d62:	80 e2       	ldi	r24, 0x20	; 32
    1d64:	a7 fc       	sbrc	r10, 7
    1d66:	8d e2       	ldi	r24, 0x2D	; 45
    1d68:	b6 01       	movw	r22, r12
    1d6a:	90 e0       	ldi	r25, 0x00	; 0
    1d6c:	0e 94 f6 0e 	call	0x1dec	; 0x1dec <fputc>
    1d70:	89 14       	cp	r8, r9
    1d72:	38 f4       	brcc	.+14     	; 0x1d82 <vfprintf+0x384>
    1d74:	b6 01       	movw	r22, r12
    1d76:	80 e3       	ldi	r24, 0x30	; 48
    1d78:	90 e0       	ldi	r25, 0x00	; 0
    1d7a:	0e 94 f6 0e 	call	0x1dec	; 0x1dec <fputc>
    1d7e:	9a 94       	dec	r9
    1d80:	f7 cf       	rjmp	.-18     	; 0x1d70 <vfprintf+0x372>
    1d82:	8a 94       	dec	r8
    1d84:	f3 01       	movw	r30, r6
    1d86:	e8 0d       	add	r30, r8
    1d88:	f1 1d       	adc	r31, r1
    1d8a:	80 81       	ld	r24, Z
    1d8c:	b6 01       	movw	r22, r12
    1d8e:	90 e0       	ldi	r25, 0x00	; 0
    1d90:	0e 94 f6 0e 	call	0x1dec	; 0x1dec <fputc>
    1d94:	81 10       	cpse	r8, r1
    1d96:	f5 cf       	rjmp	.-22     	; 0x1d82 <vfprintf+0x384>
    1d98:	22 20       	and	r2, r2
    1d9a:	09 f4       	brne	.+2      	; 0x1d9e <vfprintf+0x3a0>
    1d9c:	42 ce       	rjmp	.-892    	; 0x1a22 <vfprintf+0x24>
    1d9e:	b6 01       	movw	r22, r12
    1da0:	80 e2       	ldi	r24, 0x20	; 32
    1da2:	90 e0       	ldi	r25, 0x00	; 0
    1da4:	0e 94 f6 0e 	call	0x1dec	; 0x1dec <fputc>
    1da8:	2a 94       	dec	r2
    1daa:	f6 cf       	rjmp	.-20     	; 0x1d98 <vfprintf+0x39a>
    1dac:	f6 01       	movw	r30, r12
    1dae:	86 81       	ldd	r24, Z+6	; 0x06
    1db0:	97 81       	ldd	r25, Z+7	; 0x07
    1db2:	02 c0       	rjmp	.+4      	; 0x1db8 <vfprintf+0x3ba>
    1db4:	8f ef       	ldi	r24, 0xFF	; 255
    1db6:	9f ef       	ldi	r25, 0xFF	; 255
    1db8:	2b 96       	adiw	r28, 0x0b	; 11
    1dba:	e2 e1       	ldi	r30, 0x12	; 18
    1dbc:	0c 94 ac 0f 	jmp	0x1f58	; 0x1f58 <__epilogue_restores__>

00001dc0 <strnlen_P>:
    1dc0:	fc 01       	movw	r30, r24
    1dc2:	05 90       	lpm	r0, Z+
    1dc4:	61 50       	subi	r22, 0x01	; 1
    1dc6:	70 40       	sbci	r23, 0x00	; 0
    1dc8:	01 10       	cpse	r0, r1
    1dca:	d8 f7       	brcc	.-10     	; 0x1dc2 <strnlen_P+0x2>
    1dcc:	80 95       	com	r24
    1dce:	90 95       	com	r25
    1dd0:	8e 0f       	add	r24, r30
    1dd2:	9f 1f       	adc	r25, r31
    1dd4:	08 95       	ret

00001dd6 <strnlen>:
    1dd6:	fc 01       	movw	r30, r24
    1dd8:	61 50       	subi	r22, 0x01	; 1
    1dda:	70 40       	sbci	r23, 0x00	; 0
    1ddc:	01 90       	ld	r0, Z+
    1dde:	01 10       	cpse	r0, r1
    1de0:	d8 f7       	brcc	.-10     	; 0x1dd8 <strnlen+0x2>
    1de2:	80 95       	com	r24
    1de4:	90 95       	com	r25
    1de6:	8e 0f       	add	r24, r30
    1de8:	9f 1f       	adc	r25, r31
    1dea:	08 95       	ret

00001dec <fputc>:
    1dec:	0f 93       	push	r16
    1dee:	1f 93       	push	r17
    1df0:	cf 93       	push	r28
    1df2:	df 93       	push	r29
    1df4:	fb 01       	movw	r30, r22
    1df6:	23 81       	ldd	r18, Z+3	; 0x03
    1df8:	21 fd       	sbrc	r18, 1
    1dfa:	03 c0       	rjmp	.+6      	; 0x1e02 <fputc+0x16>
    1dfc:	8f ef       	ldi	r24, 0xFF	; 255
    1dfe:	9f ef       	ldi	r25, 0xFF	; 255
    1e00:	2c c0       	rjmp	.+88     	; 0x1e5a <fputc+0x6e>
    1e02:	22 ff       	sbrs	r18, 2
    1e04:	16 c0       	rjmp	.+44     	; 0x1e32 <fputc+0x46>
    1e06:	46 81       	ldd	r20, Z+6	; 0x06
    1e08:	57 81       	ldd	r21, Z+7	; 0x07
    1e0a:	24 81       	ldd	r18, Z+4	; 0x04
    1e0c:	35 81       	ldd	r19, Z+5	; 0x05
    1e0e:	42 17       	cp	r20, r18
    1e10:	53 07       	cpc	r21, r19
    1e12:	44 f4       	brge	.+16     	; 0x1e24 <fputc+0x38>
    1e14:	a0 81       	ld	r26, Z
    1e16:	b1 81       	ldd	r27, Z+1	; 0x01
    1e18:	9d 01       	movw	r18, r26
    1e1a:	2f 5f       	subi	r18, 0xFF	; 255
    1e1c:	3f 4f       	sbci	r19, 0xFF	; 255
    1e1e:	31 83       	std	Z+1, r19	; 0x01
    1e20:	20 83       	st	Z, r18
    1e22:	8c 93       	st	X, r24
    1e24:	26 81       	ldd	r18, Z+6	; 0x06
    1e26:	37 81       	ldd	r19, Z+7	; 0x07
    1e28:	2f 5f       	subi	r18, 0xFF	; 255
    1e2a:	3f 4f       	sbci	r19, 0xFF	; 255
    1e2c:	37 83       	std	Z+7, r19	; 0x07
    1e2e:	26 83       	std	Z+6, r18	; 0x06
    1e30:	14 c0       	rjmp	.+40     	; 0x1e5a <fputc+0x6e>
    1e32:	8b 01       	movw	r16, r22
    1e34:	ec 01       	movw	r28, r24
    1e36:	fb 01       	movw	r30, r22
    1e38:	00 84       	ldd	r0, Z+8	; 0x08
    1e3a:	f1 85       	ldd	r31, Z+9	; 0x09
    1e3c:	e0 2d       	mov	r30, r0
    1e3e:	09 95       	icall
    1e40:	89 2b       	or	r24, r25
    1e42:	e1 f6       	brne	.-72     	; 0x1dfc <fputc+0x10>
    1e44:	d8 01       	movw	r26, r16
    1e46:	16 96       	adiw	r26, 0x06	; 6
    1e48:	8d 91       	ld	r24, X+
    1e4a:	9c 91       	ld	r25, X
    1e4c:	17 97       	sbiw	r26, 0x07	; 7
    1e4e:	01 96       	adiw	r24, 0x01	; 1
    1e50:	17 96       	adiw	r26, 0x07	; 7
    1e52:	9c 93       	st	X, r25
    1e54:	8e 93       	st	-X, r24
    1e56:	16 97       	sbiw	r26, 0x06	; 6
    1e58:	ce 01       	movw	r24, r28
    1e5a:	df 91       	pop	r29
    1e5c:	cf 91       	pop	r28
    1e5e:	1f 91       	pop	r17
    1e60:	0f 91       	pop	r16
    1e62:	08 95       	ret

00001e64 <__ultoa_invert>:
    1e64:	fa 01       	movw	r30, r20
    1e66:	aa 27       	eor	r26, r26
    1e68:	28 30       	cpi	r18, 0x08	; 8
    1e6a:	51 f1       	breq	.+84     	; 0x1ec0 <__ultoa_invert+0x5c>
    1e6c:	20 31       	cpi	r18, 0x10	; 16
    1e6e:	81 f1       	breq	.+96     	; 0x1ed0 <__ultoa_invert+0x6c>
    1e70:	e8 94       	clt
    1e72:	6f 93       	push	r22
    1e74:	6e 7f       	andi	r22, 0xFE	; 254
    1e76:	6e 5f       	subi	r22, 0xFE	; 254
    1e78:	7f 4f       	sbci	r23, 0xFF	; 255
    1e7a:	8f 4f       	sbci	r24, 0xFF	; 255
    1e7c:	9f 4f       	sbci	r25, 0xFF	; 255
    1e7e:	af 4f       	sbci	r26, 0xFF	; 255
    1e80:	b1 e0       	ldi	r27, 0x01	; 1
    1e82:	3e d0       	rcall	.+124    	; 0x1f00 <__ultoa_invert+0x9c>
    1e84:	b4 e0       	ldi	r27, 0x04	; 4
    1e86:	3c d0       	rcall	.+120    	; 0x1f00 <__ultoa_invert+0x9c>
    1e88:	67 0f       	add	r22, r23
    1e8a:	78 1f       	adc	r23, r24
    1e8c:	89 1f       	adc	r24, r25
    1e8e:	9a 1f       	adc	r25, r26
    1e90:	a1 1d       	adc	r26, r1
    1e92:	68 0f       	add	r22, r24
    1e94:	79 1f       	adc	r23, r25
    1e96:	8a 1f       	adc	r24, r26
    1e98:	91 1d       	adc	r25, r1
    1e9a:	a1 1d       	adc	r26, r1
    1e9c:	6a 0f       	add	r22, r26
    1e9e:	71 1d       	adc	r23, r1
    1ea0:	81 1d       	adc	r24, r1
    1ea2:	91 1d       	adc	r25, r1
    1ea4:	a1 1d       	adc	r26, r1
    1ea6:	20 d0       	rcall	.+64     	; 0x1ee8 <__ultoa_invert+0x84>
    1ea8:	09 f4       	brne	.+2      	; 0x1eac <__ultoa_invert+0x48>
    1eaa:	68 94       	set
    1eac:	3f 91       	pop	r19
    1eae:	2a e0       	ldi	r18, 0x0A	; 10
    1eb0:	26 9f       	mul	r18, r22
    1eb2:	11 24       	eor	r1, r1
    1eb4:	30 19       	sub	r19, r0
    1eb6:	30 5d       	subi	r19, 0xD0	; 208
    1eb8:	31 93       	st	Z+, r19
    1eba:	de f6       	brtc	.-74     	; 0x1e72 <__ultoa_invert+0xe>
    1ebc:	cf 01       	movw	r24, r30
    1ebe:	08 95       	ret
    1ec0:	46 2f       	mov	r20, r22
    1ec2:	47 70       	andi	r20, 0x07	; 7
    1ec4:	40 5d       	subi	r20, 0xD0	; 208
    1ec6:	41 93       	st	Z+, r20
    1ec8:	b3 e0       	ldi	r27, 0x03	; 3
    1eca:	0f d0       	rcall	.+30     	; 0x1eea <__ultoa_invert+0x86>
    1ecc:	c9 f7       	brne	.-14     	; 0x1ec0 <__ultoa_invert+0x5c>
    1ece:	f6 cf       	rjmp	.-20     	; 0x1ebc <__ultoa_invert+0x58>
    1ed0:	46 2f       	mov	r20, r22
    1ed2:	4f 70       	andi	r20, 0x0F	; 15
    1ed4:	40 5d       	subi	r20, 0xD0	; 208
    1ed6:	4a 33       	cpi	r20, 0x3A	; 58
    1ed8:	18 f0       	brcs	.+6      	; 0x1ee0 <__ultoa_invert+0x7c>
    1eda:	49 5d       	subi	r20, 0xD9	; 217
    1edc:	31 fd       	sbrc	r19, 1
    1ede:	40 52       	subi	r20, 0x20	; 32
    1ee0:	41 93       	st	Z+, r20
    1ee2:	02 d0       	rcall	.+4      	; 0x1ee8 <__ultoa_invert+0x84>
    1ee4:	a9 f7       	brne	.-22     	; 0x1ed0 <__ultoa_invert+0x6c>
    1ee6:	ea cf       	rjmp	.-44     	; 0x1ebc <__ultoa_invert+0x58>
    1ee8:	b4 e0       	ldi	r27, 0x04	; 4
    1eea:	a6 95       	lsr	r26
    1eec:	97 95       	ror	r25
    1eee:	87 95       	ror	r24
    1ef0:	77 95       	ror	r23
    1ef2:	67 95       	ror	r22
    1ef4:	ba 95       	dec	r27
    1ef6:	c9 f7       	brne	.-14     	; 0x1eea <__ultoa_invert+0x86>
    1ef8:	00 97       	sbiw	r24, 0x00	; 0
    1efa:	61 05       	cpc	r22, r1
    1efc:	71 05       	cpc	r23, r1
    1efe:	08 95       	ret
    1f00:	9b 01       	movw	r18, r22
    1f02:	ac 01       	movw	r20, r24
    1f04:	0a 2e       	mov	r0, r26
    1f06:	06 94       	lsr	r0
    1f08:	57 95       	ror	r21
    1f0a:	47 95       	ror	r20
    1f0c:	37 95       	ror	r19
    1f0e:	27 95       	ror	r18
    1f10:	ba 95       	dec	r27
    1f12:	c9 f7       	brne	.-14     	; 0x1f06 <__ultoa_invert+0xa2>
    1f14:	62 0f       	add	r22, r18
    1f16:	73 1f       	adc	r23, r19
    1f18:	84 1f       	adc	r24, r20
    1f1a:	95 1f       	adc	r25, r21
    1f1c:	a0 1d       	adc	r26, r0
    1f1e:	08 95       	ret

00001f20 <__prologue_saves__>:
    1f20:	2f 92       	push	r2
    1f22:	3f 92       	push	r3
    1f24:	4f 92       	push	r4
    1f26:	5f 92       	push	r5
    1f28:	6f 92       	push	r6
    1f2a:	7f 92       	push	r7
    1f2c:	8f 92       	push	r8
    1f2e:	9f 92       	push	r9
    1f30:	af 92       	push	r10
    1f32:	bf 92       	push	r11
    1f34:	cf 92       	push	r12
    1f36:	df 92       	push	r13
    1f38:	ef 92       	push	r14
    1f3a:	ff 92       	push	r15
    1f3c:	0f 93       	push	r16
    1f3e:	1f 93       	push	r17
    1f40:	cf 93       	push	r28
    1f42:	df 93       	push	r29
    1f44:	cd b7       	in	r28, 0x3d	; 61
    1f46:	de b7       	in	r29, 0x3e	; 62
    1f48:	ca 1b       	sub	r28, r26
    1f4a:	db 0b       	sbc	r29, r27
    1f4c:	0f b6       	in	r0, 0x3f	; 63
    1f4e:	f8 94       	cli
    1f50:	de bf       	out	0x3e, r29	; 62
    1f52:	0f be       	out	0x3f, r0	; 63
    1f54:	cd bf       	out	0x3d, r28	; 61
    1f56:	09 94       	ijmp

00001f58 <__epilogue_restores__>:
    1f58:	2a 88       	ldd	r2, Y+18	; 0x12
    1f5a:	39 88       	ldd	r3, Y+17	; 0x11
    1f5c:	48 88       	ldd	r4, Y+16	; 0x10
    1f5e:	5f 84       	ldd	r5, Y+15	; 0x0f
    1f60:	6e 84       	ldd	r6, Y+14	; 0x0e
    1f62:	7d 84       	ldd	r7, Y+13	; 0x0d
    1f64:	8c 84       	ldd	r8, Y+12	; 0x0c
    1f66:	9b 84       	ldd	r9, Y+11	; 0x0b
    1f68:	aa 84       	ldd	r10, Y+10	; 0x0a
    1f6a:	b9 84       	ldd	r11, Y+9	; 0x09
    1f6c:	c8 84       	ldd	r12, Y+8	; 0x08
    1f6e:	df 80       	ldd	r13, Y+7	; 0x07
    1f70:	ee 80       	ldd	r14, Y+6	; 0x06
    1f72:	fd 80       	ldd	r15, Y+5	; 0x05
    1f74:	0c 81       	ldd	r16, Y+4	; 0x04
    1f76:	1b 81       	ldd	r17, Y+3	; 0x03
    1f78:	aa 81       	ldd	r26, Y+2	; 0x02
    1f7a:	b9 81       	ldd	r27, Y+1	; 0x01
    1f7c:	ce 0f       	add	r28, r30
    1f7e:	d1 1d       	adc	r29, r1
    1f80:	0f b6       	in	r0, 0x3f	; 63
    1f82:	f8 94       	cli
    1f84:	de bf       	out	0x3e, r29	; 62
    1f86:	0f be       	out	0x3f, r0	; 63
    1f88:	cd bf       	out	0x3d, r28	; 61
    1f8a:	ed 01       	movw	r28, r26
    1f8c:	08 95       	ret

00001f8e <_exit>:
    1f8e:	f8 94       	cli

00001f90 <__stop_program>:
    1f90:	ff cf       	rjmp	.-2      	; 0x1f90 <__stop_program>
